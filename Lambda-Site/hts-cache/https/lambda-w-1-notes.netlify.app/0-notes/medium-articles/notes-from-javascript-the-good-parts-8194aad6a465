<!DOCTYPE html><html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Notes from JavaScript the Good Parts</title><style>
      * {
        font-family: Georgia, Cambria, "Times New Roman", Times, serif;
      }
      html, body {
        margin: 0;
        padding: 0;
      }
      h1 {
        font-size: 50px;
        margin-bottom: 17px;
        color: #333;
      }
      h2 {
        font-size: 24px;
        line-height: 1.6;
        margin: 30px 0 0 0;
        margin-bottom: 18px;
        margin-top: 33px;
        color: #333;
      }
      h3 {
        font-size: 30px;
        margin: 10px 0 20px 0;
        color: #333;
      }
      header {
        width: 640px;
        margin: auto;
      }
      section {
        width: 640px;
        margin: auto;
      }
      section p {
        margin-bottom: 27px;
        font-size: 20px;
        line-height: 1.6;
        color: #333;
      }
      section img {
        max-width: 640px;
      }
      footer {
        padding: 0 20px;
        margin: 50px 0;
        text-align: center;
        font-size: 12px;
      }
      .aspectRatioPlaceholder {
        max-width: auto !important;
        max-height: auto !important;
      }
      .aspectRatioPlaceholder-fill {
        padding-bottom: 0 !important;
      }
      header,
      section[data-field=subtitle],
      section[data-field=description] {
        display: none;
      }
      </style></head><body><article class="h-entry">
<header>
<h1 class="p-name">Notes from JavaScript the Good Parts</h1>
</header>
<section data-field="subtitle" class="p-summary">
A condensed summary of the entire “JavaScript the Good Parts” book
</section>
<section data-field="body" class="e-content">
<section name="1e99" class="section section--body section--first section--last"><div class="section-divider"><hr class="section-divider"></div><div class="section-content"><div class="section-inner sectionLayout--insetColumn"><h3 name="39b5" id="39b5" class="graf graf--h3 graf--leading graf--title">Notes from JavaScript the Good Parts</h3><h4 name="f44d" id="f44d" class="graf graf--h4 graf-after--h3 graf--subtitle">A condensed summary of the entire “JavaScript the Good Parts” book</h4><p name="b50b" id="b50b" class="graf graf--p graf-after--h4">I hope these notes help shed some light and save some time… (this is the most I could condense an entire book)</p><figure name="b8cd" id="b8cd" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="1*5OamO6QxV9dZTOUC5oe-uQ.png" data-width="726" data-height="419" data-is-featured="true" src="https://cdn-images-1.medium.com/max/800/1*5OamO6QxV9dZTOUC5oe-uQ.png"></figure><h3 name="2d91" id="2d91" class="graf graf--h3 graf-after--figure">Chapter 1 — Good Parts</h3><blockquote name="2543" id="2543" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">Most programming languages contain good parts and bad parts. I discovered that I could be a better programmer by using only the good parts and avoiding the bad parts. After all, how can you build something good out of bad parts?</em></blockquote><p name="1535" id="1535" class="graf graf--p graf-after--blockquote">The best parts of Javascript include:</p><ul class="postList"><li name="01f8" id="01f8" class="graf graf--li graf-after--p">functions</li><li name="a313" id="a313" class="graf graf--li graf-after--li">loose typing (variables are declared as variables, without a type)</li><li name="4e84" id="4e84" class="graf graf--li graf-after--li">dynamic objects</li><li name="0ff3" id="0ff3" class="graf graf--li graf-after--li">object literal notation (where you can create an object already with a list of key/value pairs inside curly braces)</li></ul><p name="20f9" id="20f9" class="graf graf--p graf-after--li">The worst parts include global variables — there is a common <em class="markup--em markup--p-em">global object</em> namespace where they're all lumped together and they're essential to the language.</p><p name="07db" id="07db" class="graf graf--p graf-after--p">Javascript has a <em class="markup--em markup--p-em">class free</em> object makeup, relying instead on objects inheriting properties directly from other objects — this is prototypal inheritance.</p><h3 name="afed" id="afed" class="graf graf--h3 graf-after--p">Chapter 2 — Grammar</h3><p name="4e8f" id="4e8f" class="graf graf--p graf-after--h3">Always use // for comments, even multi-line ones to avoid having to escape <code class="markup--code markup--p-code">/*</code> characters.</p><h3 name="1522" id="1522" class="graf graf--h3 graf-after--p">Numbers</h3><ul class="postList"><li name="f07d" id="f07d" class="graf graf--li graf-after--h3">There is a single, 64-bit floating point number type.</li><li name="5da1" id="5da1" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">NaN</code> (Not-a-Number) is not equal to any value (including itself) and is essentially an illegal number value, but <em class="markup--em markup--li-em">typeOf(NaN)===number is true</em></li><li name="0185" id="0185" class="graf graf--li graf-after--li">Use <code class="markup--code markup--li-code">isNaN(number)</code> to check for NaNs</li></ul><p name="dc19" id="dc19" class="graf graf--p graf-after--li">Number methods are discussed in <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Chapter 8</a>.</p><h3 name="b0ea" id="b0ea" class="graf graf--h3 graf-after--p">Strings</h3><ul class="postList"><li name="68d7" id="68d7" class="graf graf--li graf-after--h3">16-bit character set and don't have character types.</li><li name="2159" id="2159" class="graf graf--li graf-after--li">Backslashes (\) are used for escaping characters that could cause problems in strings.</li><li name="49c6" id="49c6" class="graf graf--li graf-after--li">Strings are immutable.</li></ul><p name="6fae" id="6fae" class="graf graf--p graf-after--li">Single quotes are often used to define a String in JavaScript, but if a person's name has an apostrophe (and the developer does not know the difference between an apostrophe and single quote) it is useful to “escape” the apostrophe character:</p><pre name="7fc6" id="7fc6" class="graf graf--pre graf-after--p">var name = &#39;Patrick O\&#39;Brian&#39;; // using a backslash in front of the apostrophe<br>console.log(&#39;name:&#39;, name); // name: Patrick O&#39;Brian</pre><p name="3975" id="3975" class="graf graf--p graf-after--pre">further reading: <a href="https://webdesignledger.com/common-typography-mistakes-apostrophes-versus-quotation-marks" data-href="https://webdesignledger.com/common-typography-mistakes-apostrophes-versus-quotation-marks" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">https://webdesignledger.com/common-typography-mistakes-apostrophes-versus-quotation-marks</a></p><figure name="56d3" id="56d3" class="graf graf--figure graf-after--p"><img class="graf-image" data-image-id="0*flaXqCb0qgSPDaM_.png" data-width="470" data-height="462" src="https://cdn-images-1.medium.com/max/800/0*flaXqCb0qgSPDaM_.png"></figure><p name="18e2" id="18e2" class="graf graf--p graf-after--figure">String methods are discussed in <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Chapter 8</a>.</p><h3 name="5d07" id="5d07" class="graf graf--h3 graf-after--p">Statements</h3><ul class="postList"><li name="01bb" id="01bb" class="graf graf--li graf-after--h3"><em class="markup--em markup--li-em">Inside</em> a function, the var statement creates variables local to that function</li><li name="4570" id="4570" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">switch, while, for</em> and <em class="markup--em markup--li-em">do</em> statements can have an optional label which can be used with <code class="markup--code markup--li-code">break</code> and <code class="markup--code markup--li-code">continue</code> to provide more precise <a href="http://www.tutorialspoint.com/cgi-bin/practice.cgi?file=javascript_19" data-href="http://www.tutorialspoint.com/cgi-bin/practice.cgi?file=javascript_19" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">control over exactly which statement to break or continue</a>. Format: <code class="markup--code markup--li-code">labelname: statement</code> and then <code class="markup--code markup--li-code">continue labelname;</code></li><li name="2a70" id="2a70" class="graf graf--li graf-after--li">ES2015 presents two new keywords for declaring variables, <em class="markup--em markup--li-em">let</em> and <em class="markup--em markup--li-em">const</em>. Whereas the <em class="markup--em markup--li-em">var</em> keyword is function scoped (the variables are local to the function), <em class="markup--em markup--li-em">let</em> and <em class="markup--em markup--li-em">const</em> are both block scoped, which means they are local to any statement with {}.</li><li name="e510" id="e510" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">falsy</em> values:</li><li name="360f" id="360f" class="graf graf--li graf-after--li">false</li><li name="9785" id="9785" class="graf graf--li graf-after--li">null</li><li name="2592" id="2592" class="graf graf--li graf-after--li">undefined</li><li name="eb0c" id="eb0c" class="graf graf--li graf-after--li">Empty string ‘ ‘</li><li name="b86d" id="b86d" class="graf graf--li graf-after--li">The number 0</li><li name="c4ca" id="c4ca" class="graf graf--li graf-after--li">The number NaN</li><li name="e8cd" id="e8cd" class="graf graf--li graf-after--li">All other values are <em class="markup--em markup--li-em">truthy</em> including all objects &amp; the string ‘false'</li><li name="1a49" id="1a49" class="graf graf--li graf-after--li">If no matches are found in <code class="markup--code markup--li-code">case</code> statements, the optional default statement is executed, otherwise the matching case statement is carried out</li><li name="01d3" id="01d3" class="graf graf--li graf-after--li">When using a <em class="markup--em markup--li-em">for in</em> loop, usually a good idea to use <code class="markup--code markup--li-code">hasOwnProperty(variable)</code> to make sure the property belongs to the object you want and is not instead an inherited property from the prototype chain:</li></ul><pre name="0e35" id="0e35" class="graf graf--pre graf-after--li">for (myvariable in object) { <br>    if (object.hasOwnProperty(myvariable)) {<br>     //....statements to be executed <br>    } <br>}</pre><ul class="postList"><li name="e2b1" id="e2b1" class="graf graf--li graf-after--pre">A <em class="markup--em markup--li-em">do while</em> statement is always executed at least once as the while condition is only checked after the first iteration of the loop</li><li name="647a" id="647a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">catch</code> clause in a <em class="markup--em markup--li-em">try</em> statement must create a new variable that will catch the exception object</li><li name="e0f4" id="e0f4" class="graf graf--li graf-after--li">Scope of <code class="markup--code markup--li-code">throw</code> statement is the <code class="markup--code markup--li-code">try</code> block it&#39;s in, or the <code class="markup--code markup--li-code">try</code> of the function it&#39;s in</li><li name="c182" id="c182" class="graf graf--li graf-after--li">If there is no <code class="markup--code markup--li-code">return</code> statement, <code class="markup--code markup--li-code">return===undefined</code></li><li name="5f61" id="5f61" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">break</code> exits the statement and <code class="markup--code markup--li-code">continue</code> forces a new iteration of the loop, both with the optional <em class="markup--em markup--li-em">label</em> mentioned above</li></ul><h3 name="cb6e" id="cb6e" class="graf graf--h3 graf-after--li">Expressions</h3><ul class="postList"><li name="adb6" id="adb6" class="graf graf--li graf-after--h3">For <code class="markup--code markup--li-code">expression ? expression2 : expression3</code>, if expression is <em class="markup--em markup--li-em">truthy</em>, execute expresion2; if it&#39;s <em class="markup--em markup--li-em">falsy</em>, execute expression3</li><li name="7f14" id="7f14" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Invocation</em> is <code class="markup--code markup--li-code">(expression1, expression2, etc)</code></li><li name="3212" id="3212" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">refinement</em> is either <code class="markup--code markup--li-code">.name</code> or <code class="markup--code markup--li-code">[expression]</code> as used in an array</li></ul><h3 name="e249" id="e249" class="graf graf--h3 graf-after--li">Literals</h3><ul class="postList"><li name="598c" id="598c" class="graf graf--li graf-after--h3"><em class="markup--em markup--li-em">Names</em> or <em class="markup--em markup--li-em">strings</em> used for specifying new objects (<a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">object literals</a>) or arrays (<a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">array literals</a>)</li><li name="da68" id="da68" class="graf graf--li graf-after--li">Properties of the object are expressions and must be known at compile time</li></ul><h3 name="c83a" id="c83a" class="graf graf--h3 graf-after--li">Functions</h3><ul class="postList"><li name="1ffe" id="1ffe" class="graf graf--li graf-after--h3">A function literal defines a function value</li><li name="5f0c" id="5f0c" class="graf graf--li graf-after--li">More details in <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Chapter 4</a></li></ul><h3 name="a7a2" id="a7a2" class="graf graf--h3 graf-after--li">Chapter 3 — Objects</h3><p name="be44" id="be44" class="graf graf--p graf-after--h3">Javascript simple types:</p><ul class="postList"><li name="5a44" id="5a44" class="graf graf--li graf-after--p">numbers <em class="markup--em markup--li-em">(has object-like methods but they are immutable)</em></li><li name="8cd7" id="8cd7" class="graf graf--li graf-after--li">strings <em class="markup--em markup--li-em">(has object-like methods but they are immutable)</em></li><li name="7ed9" id="7ed9" class="graf graf--li graf-after--li">booleans <em class="markup--em markup--li-em">(has object-like methods but they are immutable)</em></li><li name="420c" id="420c" class="graf graf--li graf-after--li">null</li><li name="b51f" id="b51f" class="graf graf--li graf-after--li">undefined</li></ul><p name="3c3a" id="3c3a" class="graf graf--p graf-after--li">All other values are <em class="markup--em markup--p-em">objects</em> including arrays and functions.</p><p name="9a21" id="9a21" class="graf graf--p graf-after--p">Objects are class free, can contain other objects and can inherit properties from their prototypes (which can <em class="markup--em markup--p-em">reduce object initialisation time and memory consumption</em>).</p><h3 name="f4c6" id="f4c6" class="graf graf--h3 graf-after--p">Object Literals</h3><ul class="postList"><li name="b0a3" id="b0a3" class="graf graf--li graf-after--h3">An object literal is <em class="markup--em markup--li-em">zero or more comma-separated name/value pairs surrounded by curly braces</em> {}</li></ul><pre name="5a73" id="5a73" class="graf graf--pre graf-after--li">var empty_object = {};</pre><pre name="b523" id="b523" class="graf graf--pre graf-after--pre">var today = {<br>    day: &quot;Wednesday&quot;,<br>    month: &quot;April&quot;,<br>    year: 2014,</pre><pre name="2ebd" id="2ebd" class="graf graf--pre graf-after--pre">    weather: { //objects can contain nested objects like this one<br>        morning: &quot;sunny&quot;,<br>        afternoon: &quot;cloudy&quot;<br>    }<br>}</pre><h3 name="61ea" id="61ea" class="graf graf--h3 graf-after--pre">Retrieval</h3><ul class="postList"><li name="ee43" id="ee43" class="graf graf--li graf-after--h3">Can be done with either dot notation <code class="markup--code markup--li-code">today.weather.morning</code> or with square brackets <code class="markup--code markup--li-code">today[&#39;month&#39;]</code></li><li name="d7ae" id="d7ae" class="graf graf--li graf-after--li">Or operand (||) can be used to fill in default values for nonexistent data to prevent and <em class="markup--em markup--li-em">undefined</em> error: <code class="markup--code markup--li-code">var weath = today.weather.evening || &quot;unknown&quot;</code></li></ul><h3 name="dcbb" id="dcbb" class="graf graf--h3 graf-after--li">Update</h3><ul class="postList"><li name="2d21" id="2d21" class="graf graf--li graf-after--h3">Assigning a property value to an object overwrites any existing property values with that property name</li></ul><h3 name="8277" id="8277" class="graf graf--h3 graf-after--li">Reference</h3><ul class="postList"><li name="413d" id="413d" class="graf graf--li graf-after--h3">Objects refer to each other, they don't hold duplicate copies of data</li></ul><h3 name="4a46" id="4a46" class="graf graf--h3 graf-after--li">Prototype</h3><ul class="postList"><li name="b567" id="b567" class="graf graf--li graf-after--h3">Every object has a prototype object from which it inherits properties</li><li name="943e" id="943e" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Object.prototype</em> comes standard with Javascript and is almost like a ‘root parent'</li></ul><figure name="27f9" id="27f9" class="graf graf--figure graf-after--li"><img class="graf-image" data-image-id="0*1MKtZt0a5gREie59" data-width="960" data-height="207" src="https://cdn-images-1.medium.com/max/800/0*1MKtZt0a5gREie59"></figure><ul class="postList"><li name="2293" id="2293" class="graf graf--li graf-after--figure">The <code class="markup--code markup--li-code">Object.create</code> method is now available in ES5 (but the method is in the book if required for older versions)</li><li name="5001" id="5001" class="graf graf--li graf-after--li">If an object does not have a property you ask it for, it will keep looking up the prototype chain until it finds it</li><li name="abaf" id="abaf" class="graf graf--li graf-after--li">If the property <em class="markup--em markup--li-em">does note exist</em> anywhere in the chain, it will return <em class="markup--em markup--li-em">undefined</em></li><li name="03eb" id="03eb" class="graf graf--li graf-after--li">A new property is <em class="markup--em markup--li-em">immediately visible</em> to all of the objects below it in the chain once created</li></ul><p name="3d76" id="3d76" class="graf graf--p graf-after--li">More details in <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Chapter 6</a></p><h3 name="2151" id="2151" class="graf graf--h3 graf-after--p">Reflection</h3><ul class="postList"><li name="60ed" id="60ed" class="graf graf--li graf-after--h3">Determining what properties an object has</li><li name="a00d" id="a00d" class="graf graf--li graf-after--li">Using <code class="markup--code markup--li-code">typeof</code> includes all properties in the prototype chain including functions</li><li name="4365" id="4365" class="graf graf--li graf-after--li">To avoid inherited properties, use <code class="markup--code markup--li-code">hasOwnProperty(type);</code> which returns <em class="markup--em markup--li-em">true</em> if that property exists only in that object itself (not the chain)</li></ul><pre name="386f" id="386f" class="graf graf--pre graf-after--li">today.hasOwnProperty(‘number') //will return true today.hasOwnProperty(‘constructor') //will return false</pre><h3 name="32c4" id="32c4" class="graf graf--h3 graf-after--pre">Enumeration</h3><ul class="postList"><li name="ce3f" id="ce3f" class="graf graf--li graf-after--h3">Best way to enumerate all the properties you want is a for loop:</li></ul><pre name="70cb" id="70cb" class="graf graf--pre graf-after--li">let i;<br>var properties = [ ‘day', ‘month', ‘year' ]; <br>for (i = 0; i &lt; properties.length; i++) { <br>    document.writeIn(properties[i] + ‘:' + today[properties[i]]);<br> }</pre><ul class="postList"><li name="5d1f" id="5d1f" class="graf graf--li graf-after--pre">This ensures you get the properties you want (i.e. not up the prototype chain) and in the order you want, as opposed to a <em class="markup--em markup--li-em">for in</em> loop which achieves neither of these</li></ul><h3 name="62b2" id="62b2" class="graf graf--h3 graf-after--li">Delete</h3><ul class="postList"><li name="546d" id="546d" class="graf graf--li graf-after--h3">Removes property from object, but also reveals property from further up the prototype chain if it exists</li><li name="9258" id="9258" class="graf graf--li graf-after--li">Format: <code class="markup--code markup--li-code">delete today.month</code></li></ul><h3 name="8329" id="8329" class="graf graf--h3 graf-after--li">Global Abatement</h3><ul class="postList"><li name="5b97" id="5b97" class="graf graf--li graf-after--h3">One way to mitigate the risks of global variables is to <em class="markup--em markup--li-em">create a single global variable</em> which then contains your whole application</li></ul><pre name="b5a4" id="b5a4" class="graf graf--pre graf-after--li">let MYAPP = {}</pre><pre name="f81a" id="f81a" class="graf graf--pre graf-after--pre">MYAPP.today = {<br>    day: &quot;Wednesday&quot;,<br>    month: &quot;April&quot;,<br>    year: 2014,</pre><pre name="f334" id="f334" class="graf graf--pre graf-after--pre">    weather: { //objects can contain nested objects like this one<br>        morning: &quot;sunny&quot;,<br>        afternoon: &quot;cloudy&quot;<br>    }<br>}<br>//Making sure all other variables (like today) are contained within this one global variable (MYAPP) means none of them have global scope and therefore the risk of naming conflicts, etc in your application is reduced</pre><ul class="postList"><li name="68c5" id="68c5" class="graf graf--li graf-after--pre"><a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Closures</a> are also a way of mitigating the risks of global variables</li><li name="482d" id="482d" class="graf graf--li graf-after--li">Note: Most <a href="http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/" data-href="http://coding.smashingmagazine.com/2012/07/27/journey-through-the-javascript-mvc-jungle/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">Javascript MVCs</a> these days (2014) will take care of wrapping your app for you</li></ul><h3 name="924d" id="924d" class="graf graf--h3 graf-after--li">Chapter 4 — Functions</h3><blockquote name="7150" id="7150" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">The best thing about JavaScript is its implementation of functions.</em></blockquote><h3 name="55ea" id="55ea" class="graf graf--h3 graf-after--blockquote">Function Objects</h3><ul class="postList"><li name="6e8c" id="6e8c" class="graf graf--li graf-after--h3">Functions are objects linked to <em class="markup--em markup--li-em">function.prototype</em> (which is linked to <em class="markup--em markup--li-em">Object.prototype</em>).</li><li name="03c4" id="03c4" class="graf graf--li graf-after--li">As well as usual object behaviour, they can be invoked.</li></ul><h3 name="bc46" id="bc46" class="graf graf--h3 graf-after--li">Function Literal</h3><ul class="postList"><li name="5bcc" id="5bcc" class="graf graf--li graf-after--h3">A function literal has 4 parts:</li><li name="55b7" id="55b7" class="graf graf--li graf-after--li">The (reserved) word <code class="markup--code markup--li-code">function</code> itself</li><li name="8b76" id="8b76" class="graf graf--li graf-after--li">An <em class="markup--em markup--li-em">optional</em> name (un-named functions are considered <em class="markup--em markup--li-em">anonymous</em> functions)</li><li name="a3a4" id="a3a4" class="graf graf--li graf-after--li">Comma-seperated parameters of the function, in parentheses — <code class="markup--code markup--li-code">(parameters)</code></li><li name="34e2" id="34e2" class="graf graf--li graf-after--li">Set of statements in curly brackets to be carried out when the function is invoked — <code class="markup--code markup--li-code">{statements}</code></li></ul><pre name="f3bd" id="f3bd" class="graf graf--pre graf-after--li">//Format of a function<br>function name (parameterA, parameterB){<br>    statements;<br>}</pre><ul class="postList"><li name="38eb" id="38eb" class="graf graf--li graf-after--pre">Functions can be nested within functions and the inner function can access all the parameters of the outer function as well as its own</li></ul><h3 name="7c12" id="7c12" class="graf graf--h3 graf-after--li">Invocation</h3><ul class="postList"><li name="7812" id="7812" class="graf graf--li graf-after--h3">Stops the current function from running and tells the function you have invoked both to start and to use the arguments (values in parentheses) you have passed it in the invocation <code class="markup--code markup--li-code">function (parameters)</code></li><li name="7628" id="7628" class="graf graf--li graf-after--li">If arguments &gt; number of arguments expected, the extra values will be ignored</li><li name="a03b" id="a03b" class="graf graf--li graf-after--li">If arguments &lt; number of arguments expected, the function will assume undefined in place of the missing arguments</li><li name="e954" id="e954" class="graf graf--li graf-after--li">No error is thrown</li><li name="5fcf" id="5fcf" class="graf graf--li graf-after--li">Note: The difference between an <em class="markup--em markup--li-em">argument</em> and a <em class="markup--em markup--li-em">parameter</em> is that a parameter is usually what is used in the function literal, when you're setting up the function (almost like the placeholder for the actual values that the function will use when it is active) and an argument is usually the value passed to a function at the time it is invoked</li><li name="87d9" id="87d9" class="graf graf--li graf-after--li">Parameters <code class="markup--code markup--li-code">this</code> and <code class="markup--code markup--li-code">arguments</code> are also passed to the function when it is invoked, but their value depends on how the function is invoked</li></ul><h4 name="2443" id="2443" class="graf graf--h4 graf-after--li">Method Invocation Pattern</h4><ul class="postList"><li name="c1d7" id="c1d7" class="graf graf--li graf-after--h4">When a function is stored as the property of the object (invoked with a dot . expression) it is called on and is called a <em class="markup--em markup--li-em">method</em></li></ul><pre name="7dcf" id="7dcf" class="graf graf--pre graf-after--li">myObject.incrementFunction();</pre><ul class="postList"><li name="add8" id="add8" class="graf graf--li graf-after--pre">The method is bound to the object and therefore can use <code class="markup--code markup--li-code">this</code> to retrieve or update values from the object</li><li name="f07b" id="f07b" class="graf graf--li graf-after--li">These methods are highly reusable</li><li name="a1e0" id="a1e0" class="graf graf--li graf-after--li">Because their <em class="markup--em markup--li-em">object context</em> comes from <code class="markup--code markup--li-code">this</code> they are considered <em class="markup--em markup--li-em">public methods</em></li></ul><h4 name="a31f" id="a31f" class="graf graf--h4 graf-after--li">Function Invocation Pattern</h4><ul class="postList"><li name="ab10" id="ab10" class="graf graf--li graf-after--h4">When a function is <em class="markup--em markup--li-em">not</em> the property of an object, it is invoked as a <em class="markup--em markup--li-em">function</em></li></ul><pre name="1ae6" id="1ae6" class="graf graf--pre graf-after--li">var sum = add(3, 4);</pre><ul class="postList"><li name="f17c" id="f17c" class="graf graf--li graf-after--pre">These functions are bound to the global object (<em class="markup--em markup--li-em">a “mistake in the design of the language” according to Douglas Crockford)</em> and consequently so is <code class="markup--code markup--li-code">this</code><a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">even in inner functions</a></li><li name="19d9" id="19d9" class="graf graf--li graf-after--li">Invoking <code class="markup--code markup--li-code">this</code> within an inner function will therefore refer to its <em class="markup--em markup--li-em">own</em> <code class="markup--code markup--li-code">this</code> and not the one in global scope</li></ul><p name="ba18" id="ba18" class="graf graf--p graf-after--li">Workaround: Artificially create a new <code class="markup--code markup--p-code">this</code>:</p><pre name="e760" id="e760" class="graf graf--pre graf-after--p">myObject.double = function() {<br>    //in the book, the var here is called `that` but name changed for clarity<br>    var globalScopeThis = this; //workaround</pre><pre name="1306" id="1306" class="graf graf--pre graf-after--pre">    var innerFunc = function() {<br>        globalScopeThis.value = add(globalScopeThis.value, globalScopeThis.value);<br>    };</pre><pre name="338f" id="338f" class="graf graf--pre graf-after--pre">    innerFunc(); //invoke innerFunc as function<br>};</pre><pre name="8c0e" id="8c0e" class="graf graf--pre graf-after--pre">myObject.double();<br>console.log(myObject.value);</pre><h4 name="55f9" id="55f9" class="graf graf--h4 graf-after--pre">Constructor Invocation Pattern</h4><ul class="postList"><li name="1e4b" id="1e4b" class="graf graf--li graf-after--h4">When a function is created with <code class="markup--code markup--li-code">new</code>, that function contains a link to the function&#39;s prototype</li><li name="0943" id="0943" class="graf graf--li graf-after--li">This means that methods that were created for the prototype function are also available to the function created using <code class="markup--code markup--li-code">new</code></li></ul><pre name="3085" id="3085" class="graf graf--pre graf-after--li">//create a function Quo that takes a string - Quo will be our prototype function as we will see<br>var Quo = function (string){<br>    this.status = string;<br>}</pre><pre name="59be" id="59be" class="graf graf--pre graf-after--pre">//Now create a get_status method for Quo - this will be a public method<br>Quo.prototype.get_status = function () {<br>    return this.status;<br>}</pre><pre name="1055" id="1055" class="graf graf--pre graf-after--pre">//create a new instance of Quo using the prefix NEW<br>var myQuo = new Quo(&quot;happy&quot;);</pre><pre name="424c" id="424c" class="graf graf--pre graf-after--pre">//because of the use of the new prefix, myQuo is an instance of Quo which means it can access the public method get_status from it&#39;s prototype<br>document.writeIn(myQuo.get_status());     //returns &#39;happy&#39;</pre><ul class="postList"><li name="b1a1" id="b1a1" class="graf graf--li graf-after--pre">This style of constructor pattern is not recommended, there will be better examples in <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Chapter 5</a> — this is noted again in <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Appendix B</a></li><li name="37ea" id="37ea" class="graf graf--li graf-after--li">The first letter of a constructor function (in this case Quo) must <em class="markup--em markup--li-em">always</em> be capitalized</li></ul><h4 name="eadf" id="eadf" class="graf graf--h4 graf-after--li">Apply Invocation Pattern</h4><ul class="postList"><li name="86a2" id="86a2" class="graf graf--li graf-after--h4">The <code class="markup--code markup--li-code">apply</code> method lets you choose the value to be bound to <code class="markup--code markup--li-code">this</code></li><li name="56e4" id="56e4" class="graf graf--li graf-after--li">It also takes the parameters for a function in an array</li><li name="5ad8" id="5ad8" class="graf graf--li graf-after--li">Format: <code class="markup--code markup--li-code">function.apply(valueForThis, arrayOfParamentersForFunction);</code></li></ul><pre name="ae85" id="ae85" class="graf graf--pre graf-after--li">var array = [5, 2]    //will be the parameters for our function<br>var sum = add.apply(null, array);     //value of &#39;this&#39; is null and value of sum is 7 as the &#39;apply&#39; method passes 5 and 2 to the &#39;add&#39; method</pre><h3 name="8237" id="8237" class="graf graf--h3 graf-after--pre">Arguments</h3><ul class="postList"><li name="af09" id="af09" class="graf graf--li graf-after--h3">Another default parameter of functions is the <code class="markup--code markup--li-code">arguments</code> array which contains all the arguments that were supplied when the function was invoked</li><li name="a106" id="a106" class="graf graf--li graf-after--li">This means you don't have to know the exact number of arguments when you build a function because you can loop through all the arguments provided at invocation with the use of the default <code class="markup--code markup--li-code">arguments</code> array</li></ul><pre name="4caf" id="4caf" class="graf graf--pre graf-after--li">//inside the function for (i = 0; i &lt; arguments.length; i++) { dosomething; //e.g. sum +=arguments[i] }</pre><ul class="postList"><li name="e50b" id="e50b" class="graf graf--li graf-after--pre"><code class="markup--code markup--li-code">arguments</code> lacks all the array methods except .length because of a bug</li></ul><h3 name="22b0" id="22b0" class="graf graf--h3 graf-after--li">Return</h3><ul class="postList"><li name="d222" id="d222" class="graf graf--li graf-after--h3">When a function gets to a <code class="markup--code markup--li-code">return</code> statement, it returns immediately without carrying out the remaining statements in the function</li><li name="017d" id="017d" class="graf graf--li graf-after--li">A function always returns a <code class="markup--code markup--li-code">value</code> or if unspecified, it returns <code class="markup--code markup--li-code">undefined</code></li><li name="63f5" id="63f5" class="graf graf--li graf--startsWithDoubleQuote graf-after--li">“If the function was invoked with the <code class="markup--code markup--li-code">new</code> prefix (used when creating a new object so it must return an object) and the <code class="markup--code markup--li-code">return</code> value is not an object, then <code class="markup--code markup--li-code">this</code> (the new object) is returned instead.&quot;</li></ul><h3 name="a34e" id="a34e" class="graf graf--h3 graf-after--li">Exceptions</h3><ul class="postList"><li name="1aa4" id="1aa4" class="graf graf--li graf-after--h3">A <code class="markup--code markup--li-code">throw</code> statement interrupts the execution of the code is used to handle expected exceptions like an incorrect type of argument (e.g. a string where a number is expected)</li><li name="bcc6" id="bcc6" class="graf graf--li graf-after--li">Each <code class="markup--code markup--li-code">throw</code> statement should have an exception object with a <code class="markup--code markup--li-code">name</code> holding the type of exception and a <code class="markup--code markup--li-code">message</code> with an explanation of it + any other properties you like</li></ul><pre name="f0b3" id="f0b3" class="graf graf--pre graf-after--li">//Thinking through what exceptions could happen in an add function, the main function contains the throw statement with the exception object <br>let add = function (a,b) { <br>    if (typeof a !== ‘number' || typeof b !== ‘number'){ <br>    throw {<br>     name: ‘TypeError'; <br>     message: ‘The add function requires numbers';<br>     } <br>  } <br>return a + b; <br>}</pre><ul class="postList"><li name="7e5c" id="7e5c" class="graf graf--li graf-after--pre">When you write a function to use <em class="markup--em markup--li-em">add()</em>, you include a <code class="markup--code markup--li-code">try</code> block where the exception object from the <code class="markup--code markup--li-code">throw</code> statement in <em class="markup--em markup--li-em">add()</em> will pass control to a single catch clause for all exceptions</li></ul><pre name="c451" id="c451" class="graf graf--pre graf-after--li">//When you use the function later on, add a try block with a catch clause to catch the exception object<br>var try_it = function () {<br>    try{<br>        add(&quot;seven&quot;);   //will throw an exception as it is not a number<br>    }<br>    catch (e) {<br>        document.writeIn(e.name + &#39;:&#39; + e.message);<br>    }<br>}</pre><pre name="3830" id="3830" class="graf graf--pre graf-after--pre">try_it();    //you could rewrite this function so the argument is passed in here where it is invoked</pre><h3 name="9cae" id="9cae" class="graf graf--h3 graf-after--pre">Augmenting Types</h3><ul class="postList"><li name="1919" id="1919" class="graf graf--li graf-after--h3">Adding a method to the prototype of an object <code class="markup--code markup--li-code">Object.prototype</code> (or function, array, string, number, regular expression or boolean), you make it available to all the instances of that object so you don&#39;t have to use the <code class="markup--code markup--li-code">prototype</code> property again</li><li name="33f8" id="33f8" class="graf graf--li graf-after--li">By augmenting the <em class="markup--em markup--li-em">basic types</em> (essentially the root prototypes), we can improve Javascript overall</li><li name="bd4c" id="bd4c" class="graf graf--li graf-after--li">For example, adding a method named <em class="markup--em markup--li-em">trim</em> to remove spaces from the end of strings, available to all String instances in your code:</li></ul><pre name="da11" id="da11" class="graf graf--pre graf-after--li">String.method (‘trim', function () { return this.replace(/ˆ\s+|\s+$/g, ‘'); //uses regular expression });</pre><ul class="postList"><li name="73e9" id="73e9" class="graf graf--li graf-after--pre">To be on the safe side, create a method conditionally, only when you know the method is missing</li></ul><pre name="4533" id="4533" class="graf graf--pre graf-after--li">//Makes a method available to all functions, ONLY when it definitely does not already exist</pre><pre name="bf05" id="bf05" class="graf graf--pre graf-after--pre">Function.prototype.method (methodName, func) {<br>    if (!this.prototype[methodName]){<br>        this.prototype[methodName] = func;<br>        return this;<br>    }<br>};</pre><ul class="postList"><li name="f51f" id="f51f" class="graf graf--li graf-after--pre">Remember that <em class="markup--em markup--li-em">for in</em> statements don't work well with prototypes</li></ul><h3 name="d4d9" id="d4d9" class="graf graf--h3 graf-after--li">Recursion</h3><ul class="postList"><li name="d1a4" id="d1a4" class="graf graf--li graf-after--h3">Used when a task can be divided into simple sub-problems and a function can <em class="markup--em markup--li-em">call itself repeatedly</em> to solve them</li><li name="0712" id="0712" class="graf graf--li graf-after--li">Takes the format:</li></ul><pre name="06e9" id="06e9" class="graf graf--pre graf-after--li">var variable = function functionName (parameters){<br>    //wrap the statements to be executed and the recursive call in a loop statement so it doesn&#39;t recurse forever<br>    //statements to be executed in the function;<br>    functionName(arguments);<br>};</pre><pre name="1c40" id="1c40" class="graf graf--pre graf-after--pre">functionName (initialArguments); //initial call to the function</pre><ul class="postList"><li name="61ca" id="61ca" class="graf graf--li graf-after--pre">Javascript does not have <em class="markup--em markup--li-em">tail recursion optimization</em> and therefore does not optimize recursive functions — this also means they sometimes fail if they “recurse very deeply”; On a side note, <em class="markup--em markup--li-em">tail call optimization</em> is now supported in <a href="https://www.ecma-international.org/ecma-262/7.0/index.html#sec-tail-position-calls" data-href="https://www.ecma-international.org/ecma-262/7.0/index.html#sec-tail-position-calls" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">ECMA-262</a></li></ul><h3 name="8a45" id="8a45" class="graf graf--h3 graf-after--li">Scope</h3><ul class="postList"><li name="2eac" id="2eac" class="graf graf--li graf-after--h3">A <em class="markup--em markup--li-em">block</em> is a set of statements contained in curly brackets {}</li><li name="f9c6" id="f9c6" class="graf graf--li graf-after--li">Javascript does not have block scope but does have function scope</li><li name="6a2c" id="6a2c" class="graf graf--li graf-after--li">All variables declared <em class="markup--em markup--li-em">anywhere</em> within a function are available everywhere in that function — i.e. and inner function will have access to the variables of the outer function in which it is defined</li><li name="fbf3" id="fbf3" class="graf graf--li graf-after--li">A variable can be <em class="markup--em markup--li-em">overwritten</em> with a new value in an inner function and that new value's scope will be just the body of the inner function — as soon as you're back out to the outer function, the value of that variable will revert to what it was before the inner function began its execution</li><li name="0c21" id="0c21" class="graf graf--li graf-after--li">All variable should be declared at the top of the function body</li></ul><h3 name="b258" id="b258" class="graf graf--h3 graf-after--li">Closure</h3><ul class="postList"><li name="989d" id="989d" class="graf graf--li graf-after--h3">Inner functions have access to the actual parameters of the outer functions (not copies)</li><li name="b019" id="b019" class="graf graf--li graf-after--li">If an object is created as a result of a function and assigned to myObject, myObject continues to share access to the variables in the functions that created it (actual variables, not copies)</li><li name="b1c7" id="b1c7" class="graf graf--li graf-after--li">It has access to <em class="markup--em markup--li-em">the context in which it was created</em> — this is <em class="markup--em markup--li-em">closure</em></li><li name="20bf" id="20bf" class="graf graf--li graf-after--li">This includes later on, even if <em class="markup--em markup--li-em">the outer function has completed its execution and returned</em>, when the inner function is called, it will still have access to all the variables it had access to at the time it was defined (i.e. the variables that were <em class="markup--em markup--li-em">in context</em> when the inner function was defined)</li></ul><h3 name="df8c" id="df8c" class="graf graf--h3 graf-after--li">Callbacks</h3><ul class="postList"><li name="b092" id="b092" class="graf graf--li graf-after--h3">A <em class="markup--em markup--li-em">callback function</em> is a function passed to another function as a parameter and executed in this other function</li><li name="c9cb" id="c9cb" class="graf graf--li graf-after--li">When making a request to a server, use an <em class="markup--em markup--li-em">asynchronous request</em> as asynchronous functions return immediately, therefore freeing up the client</li><li name="668f" id="668f" class="graf graf--li graf-after--li">In this example, we pass the callback function to the asynchronous request as a parameter so the callback function will only be called when a response is available</li></ul><pre name="8dc0" id="8dc0" class="graf graf--pre graf-after--li">request = prepare_the_request(); <br>send_request_asynchronously(request, function(response){ <br>//function being passed in as a parameter <br>display(response); <br>}<br>);</pre><h3 name="310d" id="310d" class="graf graf--h3 graf-after--pre">Module</h3><ul class="postList"><li name="ca1b" id="ca1b" class="graf graf--li graf-after--h3">A module is a function or object whose contents can be used, but its state and implementation are hidden</li><li name="7475" id="7475" class="graf graf--li graf-after--li">It is essentially using function scope and closures keep the variables and functions contained within as private as well as binding them to a non-global object — whilst still being accessible</li><li name="b0aa" id="b0aa" class="graf graf--li graf-after--li">Using the <em class="markup--em markup--li-em">module pattern</em> is widely used and good practice as it promotes information hiding (avoiding naming conflicts, etc) and encapsulation</li><li name="8f11" id="8f11" class="graf graf--li graf-after--li">This is a <a href="http://css-tricks.com/how-do-you-structure-javascript-the-module-pattern-edition/" data-href="http://css-tricks.com/how-do-you-structure-javascript-the-module-pattern-edition/" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">good article on how to use the module pattern</a> with examples</li><li name="fdca" id="fdca" class="graf graf--li graf-after--li">It can also be used to produce secure objects (see <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">durable objects</a> below)</li><li name="21c5" id="21c5" class="graf graf--li graf-after--li">Methods contained in the object do not make use of <code class="markup--code markup--li-code">this</code> or <code class="markup--code markup--li-code">that</code> so it becomes impossible to change them from outside of the object except in ways explicitly permitted by the methods (like passing them a parameter)</li><li name="d8eb" id="d8eb" class="graf graf--li graf-after--li">The methods can be <em class="markup--em markup--li-em">replaced</em> but the secrets of how these methods function (like how they generate a number for example) can't be revealed because they are not tied to a global object</li></ul><pre name="3861" id="3861" class="graf graf--pre graf-after--li">var Serial_maker = function() { <br>//all variables defined in this object are now fixed and hidden from anything outside this function <br>//see page 42 of book for full example <br>}; <br>//calls to methods passing them parameters are made here</pre><ul class="postList"><li name="52c4" id="52c4" class="graf graf--li graf-after--pre">Note: Whilst Javascript variables are usually lowercase, there is some convention around capitalizing the first letter of a Module</li></ul><h3 name="18d4" id="18d4" class="graf graf--h3 graf-after--li">Cascade</h3><ul class="postList"><li name="d128" id="d128" class="graf graf--li graf-after--h3">Some methods return nothing, albeit <code class="markup--code markup--li-code">undefined</code></li><li name="ec20" id="ec20" class="graf graf--li graf-after--li">If we alter these methods to return <code class="markup--code markup--li-code">this</code> instead of <code class="markup--code markup--li-code">undefined</code>, they return the object which can then be passed to the next method, e.g <code class="markup--code markup--li-code">getElement(myBox).move(350,150)</code> gets the element and then passes is to the <em class="markup--em markup--li-em">move</em> function for the next action</li><li name="2f3c" id="2f3c" class="graf graf--li graf-after--li">This enables <em class="markup--em markup--li-em">cascades</em>, where you call many methods on the same object in sequence because the object is passed from one method to the next (usually separated by <code class="markup--code markup--li-code">.</code> as above)</li><li name="5c47" id="5c47" class="graf graf--li graf-after--li">Cascades also stop you from trying to do too much in one method and makes your code more descriptive</li></ul><h3 name="2d52" id="2d52" class="graf graf--h3 graf-after--li">Curry</h3><ul class="postList"><li name="8eee" id="8eee" class="graf graf--li graf-after--h3">A <code class="markup--code markup--li-code">curry</code> method allows you to <em class="markup--em markup--li-em">partially evaluate</em> an existing function</li><li name="71f4" id="71f4" class="graf graf--li graf-after--li">An example is below where the function <em class="markup--em markup--li-em">expects two arguments</em>, but it is first invoked with only one (in this case using <code class="markup--code markup--li-code">curry</code> as in <code class="markup--code markup--li-code">add.curry(10);</code>) and then later passed the second argument</li><li name="ed9a" id="ed9a" class="graf graf--li graf-after--li">It can also be explained as transforming a function that takes multiple arguments (<code class="markup--code markup--li-code">add(a,b)</code>) into a chain of functions that take a single argument each (<code class="markup--code markup--li-code">addA = add(A); addA(B);</code> where the two functions are now <code class="markup--code markup--li-code">add()</code> &amp; <code class="markup--code markup--li-code">addA()</code>)</li></ul><pre name="95e2" id="95e2" class="graf graf--pre graf-after--li">//set up a simple function that we will customise with curry<br>var add = function (a,b){<br>    return a + b;<br>}</pre><pre name="6dcf" id="6dcf" class="graf graf--pre graf-after--pre">var addTen = add.curry(10);      //passes 10 as the first argument to the add() function<br>addTen(20);                     //The use of the curry method in addTen means addTen === add(10, 20);</pre><ul class="postList"><li name="d280" id="d280" class="graf graf--li graf-after--pre">Javascript does not have a <code class="markup--code markup--li-code">curry</code> method natively but this can be added to the <code class="markup--code markup--li-code">Function.protoype</code>:</li></ul><pre name="6d1d" id="6d1d" class="graf graf--pre graf-after--li">Function.method(&#39;curry&#39;, function() {<br>    var slice = Array.prototype.slice,<br>        args = slice.apply(arguments),<br>        that = this;<br>    return function() {<br>        return that.apply(null, args.concat(slice.apply(arguments)));<br>    }<br>});</pre><h3 name="46ec" id="46ec" class="graf graf--h3 graf-after--pre">Memoization</h3><ul class="postList"><li name="ada3" id="ada3" class="graf graf--li graf-after--h3">Storing the results of previous operations in objects (such as arrays) allows them to be reused without having to keep recalculating the value — this optimization is called <em class="markup--em markup--li-em">memoization</em></li><li name="23db" id="23db" class="graf graf--li graf-after--li">Adding an object to store the results <em class="markup--em markup--li-em">memoizes the function</em></li><li name="9182" id="9182" class="graf graf--li graf-after--li">Particularly useful when a function is recursive and uses the results of its previous iteration in the current iteration</li><li name="7c78" id="7c78" class="graf graf--li graf-after--li">A <em class="markup--em markup--li-em">memoizer</em> function can be created to help memoize future functions:</li></ul><pre name="f6c8" id="f6c8" class="graf graf--pre graf-after--li">var meoizer = function(memo, fundamental) {<br>    var shell = function(n) {<br>        var result = memo[n];<br>        if (typeof result !== &#39;number&#39;) {<br>            result = fundamental(shell, n);<br>            memo[n] = result;<br>        }<br>        return result;<br>    }<br>    return shell;<br>}</pre><h3 name="ef2d" id="ef2d" class="graf graf--h3 graf-after--pre">Chapter 5 — Inheritance</h3><blockquote name="fd95" id="fd95" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">Javascript is a prototypal language, which means that objects inherit directly from other objects</em></blockquote><p name="85da" id="85da" class="graf graf--p graf-after--blockquote">Main benefit of inheritance is code reuse — you only have to specify differences.</p><p name="2484" id="2484" class="graf graf--p graf-after--p">Javascript can <em class="markup--em markup--p-em">mimic</em> classical inheritance but has a much richer set of code reuse patterns</p><ul class="postList"><li name="a251" id="a251" class="graf graf--li graf-after--p">This chapter looks at the more straightforward patterns but it is always best to keep it simple</li></ul><h3 name="559c" id="559c" class="graf graf--h3 graf-after--li">Pseudoclassical</h3><ul class="postList"><li name="c242" id="c242" class="graf graf--li graf-after--h3">The pseudoclassical code reuse pattern essentially has constructor functions (functions invoked using the <code class="markup--code markup--li-code">new</code> prefix) work like classes to mimic the classical structure</li><li name="0479" id="0479" class="graf graf--li graf-after--li">All properties are public</li><li name="1e81" id="1e81" class="graf graf--li graf-after--li">If you forget to use the <code class="markup--code markup--li-code">new</code> prefix, <code class="markup--code markup--li-code">this</code> is not bound to the new object - it is instead bound to the global object and you&#39;ll be unwittingly altering these instead!</li><li name="35b4" id="35b4" class="graf graf--li graf-after--li">There is no need to use it, there are better code reuse patterns in JavaScript</li></ul><h3 name="6d19" id="6d19" class="graf graf--h3 graf-after--li">Object Specifiers</h3><p name="b9c7" id="b9c7" class="graf graf--p graf-after--h3">Rather than: <code class="markup--code markup--p-code">var myObject = maker (f, l, m, c, s)</code> which has too many parameters to remember in the right order, use an <em class="markup--em markup--p-em">object specifier</em>:</p><pre name="f5fc" id="f5fc" class="graf graf--pre graf-after--p">var myObject = maker ({      //note curly braces<br>    first: f,<br>    last: l,<br>    state: s,<br>    city: c<br>    }<br>;)</pre><p name="c161" id="c161" class="graf graf--p graf-after--pre">to contain them. They can now be listed in any order</p><p name="7ddb" id="7ddb" class="graf graf--p graf-after--p">Also useful to pass object specifiers to JSON (<a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">see Appendix E notes</a>)</p><h3 name="ba8e" id="ba8e" class="graf graf--h3 graf-after--p">Prototypal</h3><ul class="postList"><li name="5a4a" id="5a4a" class="graf graf--li graf-after--h3">Zero classes, one object inherits from another</li><li name="ea76" id="ea76" class="graf graf--li graf-after--li">Create an object literal of a useful object and then make an instance of it using the format <code class="markup--code markup--li-code">var myObject = Object.create(originalObjectName)</code></li><li name="db18" id="db18" class="graf graf--li graf-after--li">When you then customise the new object (adding properties or methods through the dot notation for example), this is <em class="markup--em markup--li-em">differential inheritance</em>, where you specify the differences from the original object</li></ul><h3 name="bfef" id="bfef" class="graf graf--h3 graf-after--li">Functional</h3><ul class="postList"><li name="7d44" id="7d44" class="graf graf--li graf-after--h3">All properties of an object are visible (Javascript has no classes so there is no such thing as a ‘private variable' which can only be seen within a class as per other languages)</li><li name="bed0" id="bed0" class="graf graf--li graf-after--li">When you use a <em class="markup--em markup--li-em">function</em> to create your original object and the same with the object instances, you're essentially utilising Javascript functional scope to create private properties and methods</li><li name="a738" id="a738" class="graf graf--li graf-after--li">The below is an example of how you would create an original object, the <code class="markup--code markup--li-code">name</code> and <code class="markup--code markup--li-code">saying</code> properties are now completely private and only accessible to the <code class="markup--code markup--li-code">get_name</code> and <code class="markup--code markup--li-code">says</code> method</li></ul><pre name="5dd8" id="5dd8" class="graf graf--pre graf-after--li">var mammal = function (spec) {<br>    var that = {};    //that is a new object which is basically a container of &#39;secrets&#39; shared to the rest of the inheritance chain</pre><pre name="1438" id="1438" class="graf graf--pre graf-after--pre">    that.get_name = function () {<br>        return spec.name;<br>    };</pre><pre name="f3b1" id="f3b1" class="graf graf--pre graf-after--pre">    that.says = function () {<br>        return spec.saying || &#39;&#39;;  //returns an empty string if no &#39;saying&#39; argument is passed through the spec object when calling mammal<br>    };<br>    return that;     //returns the object that contains the now private properties and methods (under functional scope)<br>}</pre><pre name="4aa7" id="4aa7" class="graf graf--pre graf-after--pre">var myMammal = mammal({name: &#39;Herb&#39;});</pre><p name="02e8" id="02e8" class="graf graf--p graf-after--pre">Creating an object ‘cat' can now inherit from the <code class="markup--code markup--p-code">mammal</code> constructor and only pay attention to the differences between it and <code class="markup--code markup--p-code">mammal</code>:</p><pre name="f233" id="f233" class="graf graf--pre graf-after--p">var cat = function (spec) {<br>    spec.saying = spec.saying || &#39;meow&#39;;   //if spec.saying doesn&#39;t already exists, make it &#39;meow&#39;<br>    var that = mammal(spec);      //here the object &#39;container of secrets&#39; is set up inheriting from mammal already</pre><pre name="2d6c" id="2d6c" class="graf graf--pre graf-after--pre">    //functions and property augmentations happen here</pre><pre name="f39d" id="f39d" class="graf graf--pre graf-after--pre">    return that;      //as above<br>}</pre><ul class="postList"><li name="1fd2" id="1fd2" class="graf graf--li graf-after--pre">Requires less effort and gives better encapsulation and information hiding than the pseudoclassical pattern, as well as access to super methods (see page 54 of book for super method example)</li><li name="96df" id="96df" class="graf graf--li graf-after--li">An object created using the functional pattern <em class="markup--em markup--li-em">and</em> making no use of <code class="markup--code markup--li-code">this</code> or <code class="markup--code markup--li-code">that</code> is a <em class="markup--em markup--li-em">durable object</em> and cannot be compromised by attackers</li><li name="e86d" id="e86d" class="graf graf--li graf-after--li">Briefly also discussed in <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">Module</a> section above</li><li name="7b9b" id="7b9b" class="graf graf--li graf-after--li">If you do want something to have access to the object's private properties and methods, you pass it the <code class="markup--code markup--li-code">that</code> bundle (i.e. your &#39;container of secrets&#39;)</li></ul><h3 name="f4b3" id="f4b3" class="graf graf--h3 graf-after--li">Parts</h3><ul class="postList"><li name="067a" id="067a" class="graf graf--li graf-after--h3">An object can be composed out of a set of parts</li><li name="d914" id="d914" class="graf graf--li graf-after--li">For example, you can create a function that provides the object it is passed with a number of methods (which are defined in this function), where each method is a part that is added to the object</li></ul><h3 name="9e46" id="9e46" class="graf graf--h3 graf-after--li">Chapter 6 — Arrays</h3><p name="1e3f" id="1e3f" class="graf graf--p graf-after--h3">Javascript only has array-like objects which are slower than ‘real' arrays.</p><p name="c5a7" id="c5a7" class="graf graf--p graf-after--p">Retrieval and updating of properties works the same as with an object <em class="markup--em markup--p-em">except with integer property names</em>.</p><p name="000e" id="000e" class="graf graf--p graf-after--p">Arrays have their own literal format and their own set of methods (<a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Chapter 8 — Methods</a>).</p><h3 name="8355" id="8355" class="graf graf--h3 graf-after--p">Array Literals</h3><ul class="postList"><li name="5a49" id="5a49" class="graf graf--li graf-after--h3">An array literal is a pair of square brackets surrounding zero or more comma-seperated values <code class="markup--code markup--li-code">[a, b, c, etc]</code></li><li name="66b4" id="66b4" class="graf graf--li graf-after--li">The first value will get the property name ‘0', the second will be ‘1' and so on</li><li name="e90c" id="e90c" class="graf graf--li graf-after--li">Javascript allows an array to contain any mixture of values</li></ul><h3 name="a4f4" id="a4f4" class="graf graf--h3 graf-after--li">Length</h3><ul class="postList"><li name="9c88" id="9c88" class="graf graf--li graf-after--h3">If you add to the array, the <code class="markup--code markup--li-code">length</code> property will increase to contain the new element - it will not give an error</li><li name="a2d2" id="a2d2" class="graf graf--li graf-after--li">If you set the <code class="markup--code markup--li-code">.length</code> to a smaller number than the current length of the array, it will delete any properties with a subscript &gt;= the new <code class="markup--code markup--li-code">length</code></li><li name="955d" id="955d" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">push()</code> method is sometimes useful to add an element to the end of an array</li><li name="d62a" id="d62a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">numbers.push(&#39;go&#39;) //adds the element &#39;go&#39; to the end of the numbers array</code></li></ul><h3 name="0ec1" id="0ec1" class="graf graf--h3 graf-after--li">Delete</h3><ul class="postList"><li name="cd61" id="cd61" class="graf graf--li graf-after--h3">Elements can be deleted from the array object using <code class="markup--code markup--li-code">delete</code> but this leaves a hole in the array</li><li name="ab94" id="ab94" class="graf graf--li graf-after--li">Use <code class="markup--code markup--li-code">array.splice(keyInArray, howManyElementsToDelete)</code> which changes the keys for the remaining values in the array so there is no hole left</li><li name="53f3" id="53f3" class="graf graf--li graf-after--li">May be <em class="markup--em markup--li-em">slow</em></li></ul><h3 name="1d90" id="1d90" class="graf graf--h3 graf-after--li">Enumeration</h3><ul class="postList"><li name="abd8" id="abd8" class="graf graf--li graf-after--h3">A <code class="markup--code markup--li-code">for</code> statement can be used to iterate over all the properties of an array (as it is an object)</li><li name="7cb1" id="7cb1" class="graf graf--li graf-after--li">Do not use <code class="markup--code markup--li-code">for in</code> as it does not iterate through the properties in order and sometimes pulls in from further up the prototype chain</li></ul><h3 name="bcd1" id="bcd1" class="graf graf--h3 graf-after--li">Confusion</h3><blockquote name="1217" id="1217" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">The rule is simple: when the property names [keys] are small sequential integers, you should use an array. Otherwise, use an object.</em></blockquote><ul class="postList"><li name="3b0a" id="3b0a" class="graf graf--li graf-after--blockquote">Arrays are most useful when property names are integers <em class="markup--em markup--li-em">but</em> they can also accept strings as property names</li><li name="7142" id="7142" class="graf graf--li graf-after--li">Javascript doesn't have a good way of telling an object from an array as <code class="markup--code markup--li-code">typeof array === object</code></li><li name="8159" id="8159" class="graf graf--li graf-after--li">To accurately detect arrays, have to define our own function:</li></ul><pre name="c00c" id="c00c" class="graf graf--pre graf-after--li">var is_array = function(value) {<br>        return Object.prototype.toString.apply(value) === &#39;[object Array]&#39;; <br>  //apply(value) binds `value` to `this` &amp; returns true if `this` is an array }</pre><h3 name="a4c7" id="a4c7" class="graf graf--h3 graf-after--pre">Methods</h3><ul class="postList"><li name="9927" id="9927" class="graf graf--li graf-after--h3">Array methods are stored in <code class="markup--code markup--li-code">Array.prototype</code> which can be augmented using the format:</li></ul><pre name="f02c" id="f02c" class="graf graf--pre graf-after--li">//capital A in Array means this refers to the prototype <br>Array.method(&#39;reduce&#39;, function(parameters) {<br>    //define variables and function <br>    //return a value<br>});</pre><ul class="postList"><li name="2180" id="2180" class="graf graf--li graf-after--pre">Remember, every array inherits and can use the methods you add to <code class="markup--code markup--li-code">Array.prototype</code></li><li name="b961" id="b961" class="graf graf--li graf-after--li">You can also add methods <em class="markup--em markup--li-em">directly to an array</em> because they are objects</li><li name="72d6" id="72d6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">myArray.total = function () { //statements to execute; }</code> adds a &#39;total&#39; function to the array <code class="markup--code markup--li-code">myArray</code></li><li name="b9f9" id="b9f9" class="graf graf--li graf-after--li">DO NOT USE: <code class="markup--code markup--li-code">Object.create()</code> will create an object - lacking the <code class="markup--code markup--li-code">length</code> property - not an array.</li></ul><h3 name="bd98" id="bd98" class="graf graf--h3 graf-after--li">Dimensions</h3><ul class="postList"><li name="8586" id="8586" class="graf graf--li graf-after--h3">Using <code class="markup--code markup--li-code">[]</code> will create an empty array as they are not initialized in JavaScript</li><li name="ff51" id="ff51" class="graf graf--li graf-after--li">Accessing a missing element will give you <code class="markup--code markup--li-code">undefined</code></li><li name="3127" id="3127" class="graf graf--li graf-after--li">If you have an algorithm that relies on the array not being empty and not having <code class="markup--code markup--li-code">undefined</code> values, you can write a function that will prep your array to have a certain number of defined values, essentially initializing it with certain values in place</li><li name="acb7" id="acb7" class="graf graf--li graf-after--li">An <code class="markup--code markup--li-code">Array.dim</code> function is outlined on page 63 which will allow <code class="markup--code markup--li-code">var myArray = Array.dim(10,0)</code> to make an array with 10 zeroes starting from the first position in the array(0)</li><li name="2247" id="2247" class="graf graf--li graf-after--li">Javascript only has one dimensional arrays but <em class="markup--em markup--li-em">can</em> have array of arrays</li><li name="3f02" id="3f02" class="graf graf--li graf-after--li">Two dimensional arrays (matrices) will have to be set up by the programmer</li><li name="5bfc" id="5bfc" class="graf graf--li graf-after--li">page 63 gives a method for this and for explicitly setting cell values so as not to have an empty matrix</li></ul><h3 name="aa60" id="aa60" class="graf graf--h3 graf-after--li">Chapter 7 — Regular Expressions</h3><blockquote name="0ecb" id="0ecb" class="graf graf--blockquote graf-after--h3"><em class="markup--em markup--blockquote-em">A </em>regular expression<em class="markup--em markup--blockquote-em"> is the specification of the syntax of a simple language</em></blockquote><p name="7b50" id="7b50" class="graf graf--p graf-after--blockquote">Used with <code class="markup--code markup--p-code">regexp.exec</code>, <code class="markup--code markup--p-code">regexp.test</code>, <code class="markup--code markup--p-code">string.match</code>, <code class="markup--code markup--p-code">string.replace</code>, <code class="markup--code markup--p-code">string.search</code> and <code class="markup--code markup--p-code">string.split</code> to interact with string (more in <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">Chapter 8 - Methods</a>)</p><p name="94df" id="94df" class="graf graf--p graf-after--p">Quite convoluted and difficult to read as they do not allow comments or whitespace so a JavaScript regular expression must be on a single line</p><h3 name="24b4" id="24b4" class="graf graf--h3 graf-after--p">An Example</h3><p name="5dc8" id="5dc8" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">/ˆ(?:([A-Za-z]+):)?(\/{0,3})([0-9.\-A-Za-z]+)(?::(\d+))?(?:\/([ˆ?#]*))?(?:\?([ˆ#]*))?(?:#(.*))?$/</code></p><p name="17d7" id="17d7" class="graf graf--p graf-after--p">Breaking it down one portion (<a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">factor</a>) at a time:</p><ul class="postList"><li name="fe66" id="fe66" class="graf graf--li graf-after--p">Note that the string starts and ends with a slash <code class="markup--code markup--li-code">/</code></li><li name="785f" id="785f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ˆ</code> indicates the beginning of a string</li><li name="a0db" id="a0db" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(?:([A-Za-z]+):)?</code></li><li name="a134" id="a134" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(?:...)</code> indicates a <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><em class="markup--em markup--li-em">noncapturing group</em></a>, where the &#39;...&#39; is replaced by the group that you wish to match, but not save to anywhere</li><li name="4b32" id="4b32" class="graf graf--li graf-after--li">Suffix <code class="markup--code markup--li-code">?</code> indicates the group is optional, so it could or could not exist in the string - it could even exist more than once</li><li name="1e83" id="1e83" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">()</code> around the <em class="markup--em markup--li-em">([A-Za-z]+)</em> indicates a <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank"><em class="markup--em markup--li-em">capturing group</em></a> which is therefore captured and placed in the <code class="markup--code markup--li-code">result</code> array</li><li name="9845" id="9845" class="graf graf--li graf-after--li">They groups are placed in the array in order, so the first will appear in <code class="markup--code markup--li-code">result[1]</code></li><li name="c0dc" id="c0dc" class="graf graf--li graf-after--li">Noncapturing groups are preferred to capturing groups because capturing groups have a performance penalty (on account of saving to the result array)</li><li name="72c5" id="72c5" class="graf graf--li graf-after--li">You can also have capturing groups <em class="markup--em markup--li-em">within</em> noncapturing groups such as <code class="markup--code markup--li-code"><a href="http://www.rexegg.com/regex-disambiguation.html" data-href="http://www.rexegg.com/regex-disambiguation.html" class="markup--anchor markup--li-anchor" rel="nofollow noopener" target="_blank">(?:Bob says: (\w+))</a></code></li><li name="54f9" id="54f9" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">[...]</code> indicates a character class</li><li name="d59d" id="d59d" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">A-Za-z</code> is a character class containing all 26 letters of the alphabet in both upper and lower case</li><li name="8c1c" id="8c1c" class="graf graf--li graf-after--li">Suffix <code class="markup--code markup--li-code">+</code> means character class will be matched <em class="markup--em markup--li-em">one or more times</em></li><li name="c336" id="c336" class="graf graf--li graf-after--li">Suffix <code class="markup--code markup--li-code">:</code> is matched literally (so the letters will be followed by a colon in this case)</li><li name="62e8" id="62e8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(\/{0,3})</code></li><li name="7e5a" id="7e5a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\/</code> The backslash <code class="markup--code markup--li-code">\</code> <em class="markup--em markup--li-em">escapes</em> the forward slash <code class="markup--code markup--li-code">/</code> (which traditionally symbolises the end of the regular expression literal) and together they indicate that the forward slash <code class="markup--code markup--li-code">/</code> should be matched</li><li name="55c4" id="55c4" class="graf graf--li graf-after--li">Suffix <code class="markup--code markup--li-code">{0,3}</code> means the slash <code class="markup--code markup--li-code">/</code> will be matched between 0 and 3 times</li><li name="87f5" id="87f5" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">([0-9.\-A-Za-z]+)</code></li><li name="ace8" id="ace8" class="graf graf--li graf-after--li">String made up of one or more (note the <code class="markup--code markup--li-code">+</code> at the end denoting possible multiple occurrences) digits, letters (upper or lower case), full stops (.) or hyphens (-)</li><li name="efed" id="efed" class="graf graf--li graf-after--li">Note that the hyphen was escaped with a backslash <code class="markup--code markup--li-code">\-</code> as hyphens usually denote a <em class="markup--em markup--li-em">range</em> but in this case is a hyphen within the expression</li><li name="5093" id="5093" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(?::(\d+))?</code></li><li name="f850" id="f850" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\d</code> represents a <em class="markup--em markup--li-em">digit character</em> so this will be a sequence of <em class="markup--em markup--li-em">one or more</em> digit characters (as per the <code class="markup--code markup--li-code">+</code>)</li><li name="f09a" id="f09a" class="graf graf--li graf-after--li">The digit characters will be immediately preceded by a colon <code class="markup--code markup--li-code">:</code></li><li name="3820" id="3820" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(\d+)</code> will be the fourth capturing group in this expression, it is also <em class="markup--em markup--li-em">optional</em> (<code class="markup--code markup--li-code">?</code>) and inside a non-capturing group <code class="markup--code markup--li-code">(?:...)</code></li><li name="89e6" id="89e6" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(?:\/([ˆ?#]*))?</code></li><li name="4c1c" id="4c1c" class="graf graf--li graf-after--li">Another optional group (<code class="markup--code markup--li-code">?</code>), beginning with a literal slash <code class="markup--code markup--li-code">/</code> (escaped by the backslash)</li><li name="61f6" id="61f6" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">ˆ</code> at the beginning of character class <code class="markup--code markup--li-code">[ˆ?#]</code> means it includes <em class="markup--em markup--li-em">all</em> characters <em class="markup--em markup--li-em">except</em> ? and #</li><li name="0b8e" id="0b8e" class="graf graf--li graf-after--li">This actually leaves the regexp open to attack because too many characters are included in the character class</li><li name="f539" id="f539" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">*</code> indicates the character class will appear <em class="markup--em markup--li-em">zero or more</em> times</li><li name="ad40" id="ad40" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(?:\?([ˆ#]*))?</code></li><li name="4697" id="4697" class="graf graf--li graf-after--li">We've seen everything here before: An optional capturing group starting with a literal <code class="markup--code markup--li-code">?</code> (escaped by the backslash) with zero or more characters that are not #</li><li name="e013" id="e013" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(?:#(.*))?</code></li><li name="0739" id="0739" class="graf graf--li graf-after--li">Final optional group beginning with a <code class="markup--code markup--li-code">#</code></li><li name="96f0" id="96f0" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">.</code> matches any character <em class="markup--em markup--li-em">except a line ending character</em></li><li name="9254" id="9254" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">$</code> represents the end of a string</li><li name="409f" id="409f" class="graf graf--li graf-after--li">Note: <code class="markup--code markup--li-code">ˆ</code> and <code class="markup--code markup--li-code">$</code> are important because they anchor the regexp and checks whether the string matched against it contains <em class="markup--em markup--li-em">only</em> what is in the regexp</li><li name="5238" id="5238" class="graf graf--li graf-after--li">If <code class="markup--code markup--li-code">ˆ</code> and <code class="markup--code markup--li-code">$</code> weren&#39;t present, it would check that the string <em class="markup--em markup--li-em">contained</em> the regexp but wouldn&#39;t necessarily be only made up of this</li><li name="0fac" id="0fac" class="graf graf--li graf-after--li">Using only <code class="markup--code markup--li-code">ˆ</code> checks the string <em class="markup--em markup--li-em">starts</em> with the regexp</li><li name="53bf" id="53bf" class="graf graf--li graf-after--li">Using only <code class="markup--code markup--li-code">$</code> checks the string <em class="markup--em markup--li-em">ends</em> with the regexp</li></ul><blockquote name="5134" id="5134" class="graf graf--blockquote graf-after--li">Another example <code class="markup--code markup--blockquote-code">/ˆ-?\d+(?:\.\d*)?(?:e[+\-]?\d+)?$/i;</code></blockquote><p name="604c" id="604c" class="graf graf--p graf-after--blockquote">Most of this we have seen before but here are the new bits:</p><ul class="postList"><li name="4979" id="4979" class="graf graf--li graf-after--p">The <code class="markup--code markup--li-code">i</code> at the end means <em class="markup--em markup--li-em">ignore case</em> when matching letters</li><li name="7385" id="7385" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">-?</code> means the minus sign is optional</li><li name="aa69" id="aa69" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">(?:\.\d*)</code> matches a decimal point followed by <em class="markup--em markup--li-em">zero or more</em> digits (123.6834.4442284 <em class="markup--em markup--li-em">does not match</em>)</li><li name="b061" id="b061" class="graf graf--li graf-after--li">Note this expression only uses <em class="markup--em markup--li-em">noncapturing</em> groups</li></ul><h3 name="9f38" id="9f38" class="graf graf--h3 graf-after--li">Construction</h3><p name="72a5" id="72a5" class="graf graf--p graf-after--h3">3 flags exist in regular expressions: <code class="markup--code markup--p-code">i</code> means insensitive - ignore the character case, <code class="markup--code markup--p-code">g</code> means global - to match multiple items and <code class="markup--code markup--p-code">m</code> means multiline - where ˆ and $ can match line-ending characters</p><p name="bb0a" id="bb0a" class="graf graf--p graf-after--p">Two ways to build a regular expression: 1. <em class="markup--em markup--p-em">Regular Expression literals</em> as per the examples above start and end with a slash <code class="markup--code markup--p-code">/</code></p><ul class="postList"><li name="0c4e" id="0c4e" class="graf graf--li graf-after--p">Here the flags are appended after the final slash, for example <code class="markup--code markup--li-code">/i</code></li><li name="5e57" id="5e57" class="graf graf--li graf-after--li">Be careful: <code class="markup--code markup--li-code">RegExp</code> objects made by regular expression literals share a single instance</li></ul><ol class="postList"><li name="a17e" id="a17e" class="graf graf--li graf-after--li">Use <code class="markup--code markup--li-code">RegExp</code> constructor</li></ol><ul class="postList"><li name="5c91" id="5c91" class="graf graf--li graf-after--li">The first parameter is the string to be made into a <code class="markup--code markup--li-code">RegExp</code> object, the second is the flag</li><li name="81c2" id="81c2" class="graf graf--li graf-after--li">Useful when all information for creating the regular expression is not available at time of programming</li><li name="7f13" id="7f13" class="graf graf--li graf-after--li">Backslashes mean something in the constructor, so these must be doubled and quotes must be escaped</li></ul><pre name="f792" id="f792" class="graf graf--pre graf-after--li">//example creating a regular expression object that matches a JavaScript string</pre><pre name="b0d1" id="b0d1" class="graf graf--pre graf-after--pre">var my_regexp = new RegExp(&quot;&#39;(?:\\\\.|[ˆ\\\\\\&#39;])*&#39;&quot;, &#39;g&#39;);</pre><h3 name="acef" id="acef" class="graf graf--h3 graf-after--pre">Elements</h3><h4 name="481d" id="481d" class="graf graf--h4 graf-after--h3">Regexp Choice</h4><p name="a32a" id="a32a" class="graf graf--p graf-after--h4"><code class="markup--code markup--p-code">|</code> provides a match if any of the sequences provided match.</p><p name="c10e" id="c10e" class="graf graf--p graf-after--p">In <code class="markup--code markup--p-code">&quot;into&quot;.match(/in|int/);</code>, the <em class="markup--em markup--p-em">in</em> will be a match so it doesn&#39;t even look at the <em class="markup--em markup--p-em">int</em>.</p><h4 name="99a1" id="99a1" class="graf graf--h4 graf-after--p">Regexp Sequence</h4><p name="4cd8" id="4cd8" class="graf graf--p graf-after--h4">A <em class="markup--em markup--p-em">regexp sequence</em> is made up of one or more regexp <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">factors</a>. If there are no quantifiers after the factor (like <code class="markup--code markup--p-code">?</code>, <code class="markup--code markup--p-code">*</code> or <code class="markup--code markup--p-code">+</code>), the factor will be matched one time.</p><h4 name="96c9" id="96c9" class="graf graf--h4 graf-after--p">Regexp Factor</h4><blockquote name="4ad3" id="4ad3" class="graf graf--blockquote graf-after--h4"><em class="markup--em markup--blockquote-em">A </em>regexp factor<em class="markup--em markup--blockquote-em"> can be a character, a parenthesized group, a character class, or an escape sequence.</em></blockquote><p name="4ebc" id="4ebc" class="graf graf--p graf-after--blockquote">It's essentially a portion of the full <code class="markup--code markup--p-code">RegExp</code>, like what we broke down the regexp above into.</p><ul class="postList"><li name="20ce" id="20ce" class="graf graf--li graf-after--p">The following special characters must all be <em class="markup--em markup--li-em">escaped</em> with a backslash <code class="markup--code markup--li-code">\</code> to be taken literally, or they will take on an alternative meaning: / [ ] ( ) { } ? + * | . ˆ$</li><li name="8569" id="8569" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">\</code> prefix does not make letters or digits literal</li><li name="647e" id="647e" class="graf graf--li graf-after--li">When unescaped:</li><li name="2d17" id="2d17" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">.</code> matches any character except line-ending</li><li name="654e" id="654e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">ˆ</code> matches the beginning of the text when <code class="markup--code markup--li-code">lastIndex</code> property is zero, or matches line-ending character when the <code class="markup--code markup--li-code">m</code> flag is present</li><li name="acf7" id="acf7" class="graf graf--li graf-after--li">Having <code class="markup--code markup--li-code">ˆ</code> inside a <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--li-anchor" rel="noopener" target="_blank">character class</a> means NOT, so [ˆ0-9] means <em class="markup--em markup--li-em">does not</em> match a digit</li><li name="db46" id="db46" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">$</code> matches the beginning of the text or a line-ending character when the <code class="markup--code markup--li-code">m</code> flag is present</li></ul><h4 name="a5e0" id="a5e0" class="graf graf--h4 graf-after--li">Regexp Escape</h4><p name="609c" id="609c" class="graf graf--p graf-after--h4">As well as escaping special characters in regexp factors, the backslash has additional uses:</p><ul class="postList"><li name="3461" id="3461" class="graf graf--li graf-after--p">As in strings, <code class="markup--code markup--li-code">\f</code> is the formfeed character, <code class="markup--code markup--li-code">\n</code> is new line, <code class="markup--code markup--li-code">\r</code> is carriage return, <code class="markup--code markup--li-code">\t</code> is tab and <code class="markup--code markup--li-code">\u</code> specifies Unicode as a 16-bit hex. But <code class="markup--code markup--li-code">\b</code> is <em class="markup--em markup--li-em">not</em> a backspace character</li><li name="9cde" id="9cde" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\d</code> === [0-9] and <code class="markup--code markup--li-code">\D</code> is the opposite, NOT (ˆ) a digit, [ˆ0-9]</li><li name="ef4c" id="ef4c" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\s</code> matches is a partial set of Unicode whitespace characters and <code class="markup--code markup--li-code">\S</code> is the opposite</li><li name="50a3" id="50a3" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\w</code> === [0-9A-Za-z] and <code class="markup--code markup--li-code">\W</code> === [ˆ0-9A-Za-z] but useless for any real world language (because of accents on letters, etc)</li><li name="d33e" id="d33e" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\1</code> refers to the text captured in group 1 so it is matched again later on in the regexp</li><li name="6d9f" id="6d9f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">\2</code> refers to group 2, <code class="markup--code markup--li-code">\3</code> to group 3 and so on</li></ul><p name="96f7" id="96f7" class="graf graf--p graf-after--li">*<code class="markup--code markup--p-code">\b</code> is a <em class="markup--em markup--p-em">bad part</em>. It was supposed to be a word-boundary anchor but is useless for multilingual applications</p><h4 name="2423" id="2423" class="graf graf--h4 graf-after--p">Regexp Group</h4><p name="6fa6" id="6fa6" class="graf graf--p graf-after--h4">Four kinds of groups:</p><ul class="postList"><li name="d67d" id="d67d" class="graf graf--li graf-after--p">Capturing: <code class="markup--code markup--li-code">(...)</code> where each group is captured into the <code class="markup--code markup--li-code">result</code> array - the first capturing group in the regexp goes into <code class="markup--code markup--li-code">result[1]</code>, the second into <code class="markup--code markup--li-code">result[2]</code> and so on</li><li name="0ff8" id="0ff8" class="graf graf--li graf-after--li">Noncapturing <code class="markup--code markup--li-code">(?:...)</code> where the text is matched, but not captured and saved anywhere, making is <em class="markup--em markup--li-em">slightly faster</em> than a capturing group (has no bearing on numbering of capturing groups)</li><li name="8d20" id="8d20" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Positive lookahead</em>, a bad part: <code class="markup--code markup--li-code">(?=...)</code> acts like a noncapturing group except after the match is made, it goes back to where text started</li><li name="9297" id="9297" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Negative lookahead</em>, a bad part: <code class="markup--code markup--li-code">(?!...)</code> is like a positive lookahead but only matches if there is no match with what is in it</li></ul><h4 name="53ac" id="53ac" class="graf graf--h4 graf-after--li">Regexp Class</h4><ul class="postList"><li name="252d" id="252d" class="graf graf--li graf-after--h4">Conveniently and easily specifies one of a set of characters using square brackets <code class="markup--code markup--li-code">[]</code>, for example vowels: <code class="markup--code markup--li-code">[aeiou]</code></li><li name="d414" id="d414" class="graf graf--li graf-after--li">Can shorten specification of all 32 ASCII special characters to [!-/:-@[-`{-˜] (note that the ` in this piece of code is a back-tick)</li><li name="a45b" id="a45b" class="graf graf--li graf-after--li">Also allows <code class="markup--code markup--li-code">ˆ</code> as the first character after the opening <code class="markup--code markup--li-code">[</code> to mean <em class="markup--em markup--li-em">NOT</em> the characters in the character set</li></ul><h4 name="712f" id="712f" class="graf graf--h4 graf-after--li">Regexp Class Escape</h4><p name="c782" id="c782" class="graf graf--p graf-after--h4">There are <em class="markup--em markup--p-em">specific</em> characters that must be escaped in a character class: — / [ ] ˆ</p><h4 name="ed82" id="ed82" class="graf graf--h4 graf-after--p">Regexp Quantifier</h4><p name="65b1" id="65b1" class="graf graf--p graf-after--h4">A <em class="markup--em markup--p-em">quantifier</em> at the end of a factor indicates how many times the factor should be matched</p><ul class="postList"><li name="b9a4" id="b9a4" class="graf graf--li graf-after--p">A number in curly braces means the factor should match that many times, so <code class="markup--code markup--li-code">/o{3}</code> matches <em class="markup--em markup--li-em">ooo</em></li><li name="f6ff" id="f6ff" class="graf graf--li graf-after--li">Two comma-seperated numbers in curly braces provide the <em class="markup--em markup--li-em">range</em> of times a factor should match, so <code class="markup--code markup--li-code">{3,5}</code> indicates it will match 3, 4 or 5 times</li><li name="7222" id="7222" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Zero or one</em> times (same thing as saying something is optional) can be <code class="markup--code markup--li-code">?</code> or <code class="markup--code markup--li-code">{0,1}</code></li><li name="b0ed" id="b0ed" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">Zero or more</em> times can be <code class="markup--code markup--li-code">*</code> or <code class="markup--code markup--li-code">{0,}</code></li><li name="1ffb" id="1ffb" class="graf graf--li graf-after--li"><em class="markup--em markup--li-em">One or more</em> times can be <code class="markup--code markup--li-code">+</code> or <code class="markup--code markup--li-code">{1,}</code></li></ul><p name="6f87" id="6f87" class="graf graf--p graf-after--li">Prefer to use ‘zero or more' or ‘one or more' matching over the ‘zero or one' matching — i.e. prefer <em class="markup--em markup--p-em">greedy</em> matching over <em class="markup--em markup--p-em">lazy</em> matching</p><h3 name="ecfb" id="ecfb" class="graf graf--h3 graf-after--p">Chapter 8 — Methods</h3><h3 name="5fbf" id="5fbf" class="graf graf--h3 graf-after--h3">Arrays</h3><h4 name="da84" id="da84" class="graf graf--h4 graf-after--h3">array.concat(item…)</h4><p name="0107" id="0107" class="graf graf--p graf-after--h4">Produces new array copying the original array with the <code class="markup--code markup--p-code">items</code> appended to it (does not modify the original array like <code class="markup--code markup--p-code">array.push(item)</code> does). If the <code class="markup--code markup--p-code">item</code> is an array, its elements are appended.</p><h4 name="0bc9" id="0bc9" class="graf graf--h4 graf-after--p">array.join(separator)</h4><p name="2057" id="2057" class="graf graf--p graf-after--h4">Creates a string of all the array's elements, separated by the <code class="markup--code markup--p-code">separator</code>. Use an empty string <code class="markup--code markup--p-code">separator</code> (&#39;&#39;) to join without separation.</p><h4 name="f2cb" id="f2cb" class="graf graf--h4 graf-after--p">array.pop()</h4><p name="51bc" id="51bc" class="graf graf--p graf-after--h4">Removes <em class="markup--em markup--p-em">last element</em> of array. Returns <code class="markup--code markup--p-code">undefined</code> for empty arrays.</p><h4 name="acb9" id="acb9" class="graf graf--h4 graf-after--p">array.push(item…)</h4><p name="9714" id="9714" class="graf graf--p graf-after--h4">Modifies the <em class="markup--em markup--p-em">array</em>, appending <code class="markup--code markup--p-code">items</code> onto the end. Returns the new <code class="markup--code markup--p-code">length</code> of the array.</p><h4 name="e841" id="e841" class="graf graf--h4 graf-after--p">array.reverse()</h4><p name="2d0d" id="2d0d" class="graf graf--p graf-after--h4"><em class="markup--em markup--p-em">Modifies</em> the array by reversing the order of the elements.</p><h4 name="240d" id="240d" class="graf graf--h4 graf-after--p">array.shift()</h4><p name="b350" id="b350" class="graf graf--p graf-after--h4">Removes the <em class="markup--em markup--p-em">first</em> element of the array (does not leave a hole in the array — same effect as using the <code class="markup--code markup--p-code">.splice(a,b)</code> method) and returns that first element.</p><h4 name="9a17" id="9a17" class="graf graf--h4 graf-after--p">array.slice(start, end)</h4><p name="a408" id="a408" class="graf graf--p graf-after--h4">Different to <code class="markup--code markup--p-code">splice</code>.</p><p name="abd0" id="abd0" class="graf graf--p graf--startsWithSingleQuote graf-after--p">‘slice' creates a new array, copying from the <code class="markup--code markup--p-code">start</code> element and stopping at the element <em class="markup--em markup--p-em">before</em> the <code class="markup--code markup--p-code">end</code> value given. If no <code class="markup--code markup--p-code">end</code> is given, default is <code class="markup--code markup--p-code">array.length</code>.</p><p name="5531" id="5531" class="graf graf--p graf-after--p">Negative values for <code class="markup--code markup--p-code">start</code> and <code class="markup--code markup--p-code">end</code> will have <code class="markup--code markup--p-code">array.length</code> added to them and if <code class="markup--code markup--p-code">start</code>&gt;<code class="markup--code markup--p-code">end</code>, it will return an empty array.</p><h4 name="3452" id="3452" class="graf graf--h4 graf-after--p">array.sort(comparefn)</h4><p name="7de2" id="7de2" class="graf graf--p graf-after--h4">JavaScript has a <code class="markup--code markup--p-code">sort()</code> method which was created only to compare strings and therefore sorts numbers incorrectly (it will sort them as 1, 15, 2, 23, 54 for example). Therefore, we have to write a comparison function which returns <em class="markup--em markup--p-em">0</em> if the two elements you are comparing are equal, a <em class="markup--em markup--p-em">positive number</em> if the first element should come first and a <em class="markup--em markup--p-em">negative number</em> if the second element should come first. Then pass this comparison function to <code class="markup--code markup--p-code">sort()</code> as a parameter to allow it to sort array elements <em class="markup--em markup--p-em">intelligently</em>.</p><p name="b980" id="b980" class="graf graf--p graf-after--p">Page 80-82 in the book takes you through various iterations of the comparison functions — for numbers, simple strings, objects and objects with multiple keys (for example if you want to sort objects by first <em class="markup--em markup--p-em">and</em> last names). These should be taken from the book when required.</p><h4 name="282d" id="282d" class="graf graf--h4 graf-after--p">array.splice(start, deleteCount, item…)</h4><p name="5bfb" id="5bfb" class="graf graf--p graf-after--h4">Removes elements from the array making sure there are no holes left in the array. It is most popularly used for deleting elements from an array.</p><p name="405a" id="405a" class="graf graf--p graf-after--p">It removes the <code class="markup--code markup--p-code">deleteCount</code> number of elements from the array starting from the <code class="markup--code markup--p-code">start</code> position. If there are <code class="markup--code markup--p-code">item</code> parameters passed to it, it will replace the deleted elements in the array with the <code class="markup--code markup--p-code">items</code>.</p><p name="0792" id="0792" class="graf graf--p graf-after--p">It returns an array containing the deleted elements.</p><h4 name="6dc9" id="6dc9" class="graf graf--h4 graf-after--p">array.unshift(item…)</h4><p name="ada8" id="ada8" class="graf graf--p graf-after--h4">Works like <code class="markup--code markup--p-code">push</code> but adds items to the front of the array instead of the end. Returns the new <code class="markup--code markup--p-code">length</code> of the array.</p><h3 name="c20f" id="c20f" class="graf graf--h3 graf-after--p">Function</h3><h4 name="dd16" id="dd16" class="graf graf--h4 graf-after--h3">function.apply(thisArg, [argArray])</h4><p name="204c" id="204c" class="graf graf--p graf-after--h4">The <code class="markup--code markup--p-code">apply</code> method invokes a function, passing in the object that will be bound to <code class="markup--code markup--p-code">this</code> and <em class="markup--em markup--p-em">optional</em> array of arguments.</p><h3 name="21fe" id="21fe" class="graf graf--h3 graf-after--p">Number</h3><h4 name="314b" id="314b" class="graf graf--h4 graf-after--h3">number.toExponentional(fractionDigits)</h4><p name="07e0" id="07e0" class="graf graf--p graf-after--h4">Converts <em class="markup--em markup--p-em">number</em> to a string in exponential form (e.g. 3.14e+0). <code class="markup--code markup--p-code">fractionDigits</code> (from 0 to 20) gives the number of decimal places.</p><h4 name="3692" id="3692" class="graf graf--h4 graf-after--p">number.toFixed(fractionDigits)</h4><p name="2e5e" id="2e5e" class="graf graf--p graf-after--h4">Converts <em class="markup--em markup--p-em">number</em> to a string in decimal form (e.g. 3.1415927). <code class="markup--code markup--p-code">fractionDigits</code> (from 0 to 20) gives the number of decimal places.</p><h4 name="7e9a" id="7e9a" class="graf graf--h4 graf-after--p">number.toPrecision(precision)</h4><p name="af4e" id="af4e" class="graf graf--p graf-after--h4">Converts <em class="markup--em markup--p-em">number</em> to a string in decimal form (e.g. 3.1415927). The difference from <code class="markup--code markup--p-code">toFixed</code> is that <code class="markup--code markup--p-code">precision</code> (from 0 to 21) gives the number of total digits.</p><h4 name="3aa7" id="3aa7" class="graf graf--h4 graf-after--p">number.toString(radix)</h4><p name="2469" id="2469" class="graf graf--p graf-after--h4">Converts <em class="markup--em markup--p-em">number</em> to a string. <code class="markup--code markup--p-code">radix</code> is an <em class="markup--em markup--p-em">optional</em> parameter between 2 and 36 and gives the <em class="markup--em markup--p-em">base</em>. The default radix is 10.</p><h3 name="edf2" id="edf2" class="graf graf--h3 graf-after--p">Object</h3><h4 name="16b5" id="16b5" class="graf graf--h4 graf-after--h3">object.hasOwnProperty(name)</h4><p name="484f" id="484f" class="graf graf--p graf-after--h4">Does not look at the property chain. Returns true if the <em class="markup--em markup--p-em">object</em> contains the property <code class="markup--code markup--p-code">name</code>.</p><h3 name="86f9" id="86f9" class="graf graf--h3 graf-after--p">RegExp</h3><h4 name="f24a" id="f24a" class="graf graf--h4 graf-after--h3">regexp.exec(string)</h4><p name="d95c" id="d95c" class="graf graf--p graf-after--h4">Most powerful (and <em class="markup--em markup--p-em">slowest</em>) regexp method.</p><p name="4c09" id="4c09" class="graf graf--p graf-after--p">Checks the <code class="markup--code markup--p-code">string</code> against the <em class="markup--em markup--p-em">regexp</em> (starting at position 0) and returns an array containing the matches. The <em class="markup--em markup--p-em">regexp</em> is set up with various capturing groups and these determine the elements that go in the array:</p><ul class="postList"><li name="9a4f" id="9a4f" class="graf graf--li graf-after--p">the 0 element of the array will contain the part of <code class="markup--code markup--li-code">string</code> that matched the <em class="markup--em markup--li-em">regexp</em></li><li name="687d" id="687d" class="graf graf--li graf-after--li">element 1 of the array will contain the text captured by the first capturing group in <em class="markup--em markup--li-em">regexp</em></li><li name="a577" id="a577" class="graf graf--li graf-after--li">element 2 of the array will contain the text captured by the second capturing group in <em class="markup--em markup--li-em">regexp</em> and so on</li><li name="7163" id="7163" class="graf graf--li graf-after--li">if the match fails, it returns <code class="markup--code markup--li-code">null</code></li></ul><p name="e9b5" id="e9b5" class="graf graf--p graf-after--li">If the <em class="markup--em markup--p-em">regexp</em> contains a <code class="markup--code markup--p-code">g</code> flag (e.g. <code class="markup--code markup--p-code">var regexp = /[ˆ&lt;&gt;]+|&lt;(\/?)([A-Za-z]+)([ˆ&lt;&gt;]*)&gt;/g;</code>), there is a lot more to look out for:</p><ul class="postList"><li name="9d72" id="9d72" class="graf graf--li graf-after--p">Searching begins at <code class="markup--code markup--li-code">regexp.lastIndex</code> (initially zero)</li><li name="e344" id="e344" class="graf graf--li graf-after--li">If a match is found, <code class="markup--code markup--li-code">lastIndex</code> becomes the position of the <em class="markup--em markup--li-em">first character of the match</em></li><li name="32d8" id="32d8" class="graf graf--li graf-after--li">If no match is found, <code class="markup--code markup--li-code">lastIndex</code> is reset to zero</li><li name="5283" id="5283" class="graf graf--li graf-after--li">If searching for multiple occurrences of a pattern by calling <code class="markup--code markup--li-code">exec</code> in a loop, ensure you <em class="markup--em markup--li-em">reset </em><code class="markup--code markup--li-code"><em class="markup--em markup--li-em">lastIndex</em></code> when exiting the loop and remember <code class="markup--code markup--li-code">ˆ</code> only matches <em class="markup--em markup--li-em">when </em><code class="markup--code markup--li-code"><em class="markup--em markup--li-em">lastIndex</em></code><em class="markup--em markup--li-em"> is equal to zero</em></li></ul><p name="b0df" id="b0df" class="graf graf--p graf-after--li">Example on page 87 of the book is worth reading to improve understanding.</p><h4 name="9152" id="9152" class="graf graf--h4 graf-after--p">regexp.test(string)</h4><p name="c46b" id="c46b" class="graf graf--p graf-after--h4">Simplest (and <em class="markup--em markup--p-em">fastest</em>) regexp method.</p><p name="966e" id="966e" class="graf graf--p graf-after--p">If <em class="markup--em markup--p-em">regexp</em> matches the <code class="markup--code markup--p-code">string</code> it returns <em class="markup--em markup--p-em">true</em>. Otherwise it returns <em class="markup--em markup--p-em">false</em>. Do not use the <code class="markup--code markup--p-code">g</code> flag with this method.</p><h3 name="ad22" id="ad22" class="graf graf--h3 graf-after--p">String</h3><h4 name="8659" id="8659" class="graf graf--h4 graf-after--h3">string.charAt(pos)</h4><p name="b986" id="b986" class="graf graf--p graf-after--h4">Returns character at position <code class="markup--code markup--p-code">pos</code> in the string <em class="markup--em markup--p-em">starting from 0</em>. If <code class="markup--code markup--p-code">pos</code> is less than zero or bigger than the string itself it return an empty string.</p><h4 name="6c5b" id="6c5b" class="graf graf--h4 graf-after--p">string.charCodeAt(pos)</h4><p name="7517" id="7517" class="graf graf--p graf-after--h4">Same as <code class="markup--code markup--p-code">charAt</code> except it returns the integer that represents the <em class="markup--em markup--p-em">code point value of the character at position </em><code class="markup--code markup--p-code"><em class="markup--em markup--p-em">pos</em></code>. Returns <code class="markup--code markup--p-code">NaN</code> if <em class="markup--em markup--p-em">string</em>.length &lt; <code class="markup--code markup--p-code">pos</code> &lt; 0.</p><h4 name="97d3" id="97d3" class="graf graf--h4 graf-after--p">string.concat(string…)</h4><p name="cb85" id="cb85" class="graf graf--p graf-after--h4">Creates new string concatenating various strings. <code class="markup--code markup--p-code">+</code> tends to be used instead of this method (e.g. <code class="markup--code markup--p-code">var cat = &#39;c&#39;+&#39;a&#39;+&#39;t&#39;;</code>)</p><h4 name="ac40" id="ac40" class="graf graf--h4 graf-after--p">string.indexOf(searchString, position)</h4><p name="43e3" id="43e3" class="graf graf--p graf-after--h4">Searches for <code class="markup--code markup--p-code">searchString</code> within <em class="markup--em markup--p-em">string</em> starting at position <code class="markup--code markup--p-code">position</code> (an optional parameter). If <code class="markup--code markup--p-code">position</code> is not provided, search starts at the beginning of the <em class="markup--em markup--p-em">string</em>. Returns the integer <em class="markup--em markup--p-em">position of the first matched character</em> or <em class="markup--em markup--p-em">-1</em> if no match is found.</p><h4 name="7029" id="7029" class="graf graf--h4 graf-after--p">string.lastIndexOf(searchString, position)</h4><p name="102e" id="102e" class="graf graf--p graf-after--h4">Same as <code class="markup--code markup--p-code">indexOf</code> but searches from the end of the string instead of the beginning.</p><h4 name="11bc" id="11bc" class="graf graf--h4 graf-after--p">string.localeCompare(that)</h4><p name="2d03" id="2d03" class="graf graf--p graf-after--h4">Compares <em class="markup--em markup--p-em">string</em> to <code class="markup--code markup--p-code">that</code> parameter and returns:</p><ul class="postList"><li name="e475" id="e475" class="graf graf--li graf-after--p">0 if <em class="markup--em markup--li-em">string</em> === <code class="markup--code markup--li-code">that</code></li><li name="3c54" id="3c54" class="graf graf--li graf-after--li">-1 if <em class="markup--em markup--li-em">string</em> &lt; <code class="markup--code markup--li-code">that</code></li></ul><p name="3008" id="3008" class="graf graf--p graf-after--li"><em class="markup--em markup--p-em">NB. ‘a' &lt; ‘A', comparison is not just in length.</em></p><h4 name="988f" id="988f" class="graf graf--h4 graf-after--p">string.match(regexp)</h4><p name="c5a5" id="c5a5" class="graf graf--p graf-after--h4">Works the same way as <code class="markup--code markup--p-code">regexp.exec(string)</code> if there is no <code class="markup--code markup--p-code">g</code> flag in the <code class="markup--code markup--p-code">regexp</code>.</p><p name="ffae" id="ffae" class="graf graf--p graf-after--p">If there is a <code class="markup--code markup--p-code">g</code> flag in teh <code class="markup--code markup--p-code">regexp</code>, it produces an array of the matches but excludes the capturing groups</p><h4 name="393b" id="393b" class="graf graf--h4 graf-after--p">string.replace(searchValue, replaceValue)</h4><p name="6be6" id="6be6" class="graf graf--p graf-after--h4">Searches for the <code class="markup--code markup--p-code">searchValue</code> in <em class="markup--em markup--p-em">string</em> and replaces it with the <code class="markup--code markup--p-code">replaceValue</code>.</p><p name="bc75" id="bc75" class="graf graf--p graf-after--p">If <code class="markup--code markup--p-code">searchValue</code> is a:</p><ul class="postList"><li name="0668" id="0668" class="graf graf--li graf-after--p">string, only its <em class="markup--em markup--li-em">first occurrence</em> will be replaced with the <code class="markup--code markup--li-code">replaceValue</code></li><li name="e3d4" id="e3d4" class="graf graf--li graf-after--li">regexp with a g flag, <em class="markup--em markup--li-em">all occurrences</em> will be replaced with the <code class="markup--code markup--li-code">replaceValue</code>; otherwise, only the <em class="markup--em markup--li-em">first occurrence</em> will be replaced</li></ul><p name="3493" id="3493" class="graf graf--p graf-after--li">If <code class="markup--code markup--p-code">replaceValue</code> is a:</p><ul class="postList"><li name="b881" id="b881" class="graf graf--li graf-after--p">string, a <code class="markup--code markup--li-code">$</code> value has a special meaning when used in the <code class="markup--code markup--li-code">replaceValue</code> that conveys what to replace - see table on page 90 for possible variations on <code class="markup--code markup--li-code">$</code></li><li name="25f0" id="25f0" class="graf graf--li graf-after--li">function, it is called for each match and the <em class="markup--em markup--li-em">string result of the function</em> is used as the replacement text</li><li name="07d1" id="07d1" class="graf graf--li graf-after--li">string result of the first call will replace capture group 1 of the <em class="markup--em markup--li-em">string</em> and so on</li></ul><h4 name="71e6" id="71e6" class="graf graf--h4 graf-after--li">string.search(regexp)</h4><p name="f2ed" id="f2ed" class="graf graf--p graf-after--h4">Similar to <code class="markup--code markup--p-code">.indexOf(string)</code> but takes a <code class="markup--code markup--p-code">regexp</code> instead of a <code class="markup--code markup--p-code">string</code>, returning the position of the first match (or -1 if there is no match). The <code class="markup--code markup--p-code">g</code> flag is ignored.</p><h4 name="9c0e" id="9c0e" class="graf graf--h4 graf-after--p">string.slice(start, end)</h4><p name="fde9" id="fde9" class="graf graf--p graf-after--h4">Creates a new string by copying the characters from the <code class="markup--code markup--p-code">start</code> position to the character before the <code class="markup--code markup--p-code">end</code> position in <em class="markup--em markup--p-em">string</em>.</p><p name="7821" id="7821" class="graf graf--p graf-after--p">The <code class="markup--code markup--p-code">end</code> parameter is <em class="markup--em markup--p-em">optional</em> and defaults to <em class="markup--em markup--p-em">string</em>.length. If either parameter is negative, <em class="markup--em markup--p-em">string</em>.length is added to it.</p><h4 name="581d" id="581d" class="graf graf--h4 graf-after--p">string.split(separator, limit)</h4><p name="4ccc" id="4ccc" class="graf graf--p graf-after--h4">Creates an array of strings by splitting apart <em class="markup--em markup--p-em">string</em> at the points where the <code class="markup--code markup--p-code">separator</code> appears (e.g. if the separator is &#39;.&#39;, ab.cd&#39; becomes [&#39;ab&#39;, &#39;cd&#39;]).</p><ul class="postList"><li name="d504" id="d504" class="graf graf--li graf-after--p">If separator is an <em class="markup--em markup--li-em">empty string</em>, an array of single characters is produced.</li><li name="2d1f" id="2d1f" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">limit</code> is <em class="markup--em markup--li-em">optional</em> and determines how many pieces are to be split off from the original <em class="markup--em markup--li-em">string</em>.</li><li name="33ba" id="33ba" class="graf graf--li graf-after--li">The <code class="markup--code markup--li-code">separator</code> can be a <code class="markup--code markup--li-code">regexp</code> but</li><li name="992e" id="992e" class="graf graf--li graf-after--li">text from capturing groups within the regexp will be included in the split — e.g. in <code class="markup--code markup--li-code">var e = text.split(/\s*(,)\s*/);</code> the commas (,) will each be included as a separate element in the resulting array</li><li name="e09e" id="e09e" class="graf graf--li graf-after--li">some systems <em class="markup--em markup--li-em">ignore empty strings</em> when the <code class="markup--code markup--li-code">separator</code> is a <code class="markup--code markup--li-code">regexp</code></li></ul><h4 name="8c29" id="8c29" class="graf graf--h4 graf-after--li">string.substring(start, end)</h4><p name="17fe" id="17fe" class="graf graf--p graf-after--h4">No reason to use, use <code class="markup--code markup--p-code">slice</code> instead.</p><h4 name="5fce" id="5fce" class="graf graf--h4 graf-after--p">string.toLocaleLowerCase()</h4><p name="104e" id="104e" class="graf graf--p graf-after--h4">Produces a new string converted to lower case, <em class="markup--em markup--p-em">using the rules for the particular locale</em> (geography).</p><h4 name="82df" id="82df" class="graf graf--h4 graf-after--p">string.toLocaleUpperCase()</h4><p name="b752" id="b752" class="graf graf--p graf-after--h4">Produces a new string converted to upper case, <em class="markup--em markup--p-em">using the rules for the particular locale</em> (geography).</p><h4 name="dbcb" id="dbcb" class="graf graf--h4 graf-after--p">string.toLowerCase()</h4><p name="7caa" id="7caa" class="graf graf--p graf-after--h4">Produces a new string converted to lower case.</p><h4 name="de99" id="de99" class="graf graf--h4 graf-after--p">string.toUpperCase()</h4><p name="5da6" id="5da6" class="graf graf--p graf-after--h4">Produces a new string converted to upper case.</p><h4 name="fa74" id="fa74" class="graf graf--h4 graf-after--p">String.fromCharCode(char…)</h4><p name="2f8b" id="2f8b" class="graf graf--p graf-after--h4">Produces a new string from a series of numbers. <code class="markup--code markup--p-code">var a = String.fromCharCode(67, 97, 116); //a === &#39;Cat&#39;</code> <em class="markup--em markup--p-em">NB. You&#39;re calling the prototype here, not replacing &#39;String&#39; with your own variable.</em></p><h3 name="f5bf" id="f5bf" class="graf graf--h3 graf-after--p">Chapter 9 — Style</h3><h4 name="efda" id="efda" class="graf graf--h4 graf-after--h3"><em class="markup--em markup--h4-em">JavaScripts's loose typing and excessive error tolerance provide little compile-time assurance of our programs' quality, so to compensate, we should code with strict discipline.</em></h4><blockquote name="e4a9" id="e4a9" class="graf graf--blockquote graf-after--h4">We should avoid the <em class="markup--em markup--blockquote-em">bad parts</em> of JavaScript, but also the useful parts that can be occasionally dangerous</blockquote><blockquote name="67e4" id="67e4" class="graf graf--blockquote graf-after--blockquote">the likelihood a program will work [as intended] is significantly enhanced by our ability to read it</blockquote><blockquote name="7104" id="7104" class="graf graf--blockquote graf-after--blockquote">Must be written in a clear, consistent style, including:</blockquote><blockquote name="f702" id="f702" class="graf graf--blockquote graf-after--blockquote">Good use of whitespace</blockquote><blockquote name="45e9" id="45e9" class="graf graf--blockquote graf-after--blockquote">Put at most one statement on a line</blockquote><blockquote name="64c0" id="64c0" class="graf graf--blockquote graf-after--blockquote">If you have to break a statement into 2 or more lines, indent the 2nd line onwards (an extra four spaces)</blockquote><blockquote name="2319" id="2319" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">Always</em> use blocks (curly braces {}) with structured statements like <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">if</em></code> and <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">while</em></code> to avoid confusion on what the statement is actually doing</blockquote><blockquote name="a800" id="a800" class="graf graf--blockquote graf-after--blockquote">Put the opening brace <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">{</em></code> on the same (first) line as the statement to avoid JavaScript&#39;s <a href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" data-href="https://github.com/Lambda-April/Unsorted-Notes/blob/main" class="markup--anchor markup--blockquote-anchor" rel="noopener" target="_blank">semicolon insertion</a> issues - i.e <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">if (a) { ...</em></code></blockquote><blockquote name="9233" id="9233" class="graf graf--blockquote graf-after--blockquote">Use line comments <code class="markup--code markup--blockquote-code"><em class="markup--em markup--blockquote-em">//comment</em></code> and not block commenting (unless you&#39;re <em class="markup--em markup--blockquote-em">commenting out</em> code)</blockquote><blockquote name="4662" id="4662" class="graf graf--blockquote graf-after--blockquote">Declare all your variables at the beginning of the function, due to JavaScript's functional scope</blockquote><ul class="postList"><li name="2721" id="2721" class="graf graf--li graf-after--blockquote">I use a single global variable to contain an application or library. Every object has its own namespace, so it is easy to use objects to organize my code. Use of closure provides further information hiding, increasing the strength of my modules.</li></ul><h3 name="47e1" id="47e1" class="graf graf--h3 graf-after--li">Chapter 10 — Beautiful Features</h3><p name="c19b" id="c19b" class="graf graf--p graf-after--h3">Each feature you add to something has a lot of different costs (documentation costs, specification, design, testing and development costs) and these are often not properly accounted for.</p><blockquote name="e275" id="e275" class="graf graf--blockquote graf-after--p"><em class="markup--em markup--blockquote-em">Features that offer value to a minority of users impose a cost on all users</em></blockquote><blockquote name="0df6" id="0df6" class="graf graf--blockquote graf-after--blockquote"><em class="markup--em markup--blockquote-em">We cope with the complexity of feature-driven design by finding and sticking with the good parts. For example, microwaves do a ton of different things, but most people just use one setting, the timer and the clock. So why not design with just the good parts?</em></blockquote><h3 name="810c" id="810c" class="graf graf--h3 graf-after--blockquote">Appendix A — the Awful Parts</h3><p name="962f" id="962f" class="graf graf--p graf-after--h3">Need to know what all the pitfalls are with these parts.</p><h3 name="e18c" id="e18c" class="graf graf--h3 graf-after--p">Global variables</h3><p name="a497" id="a497" class="graf graf--p graf-after--h3">These are variables that are visible throughout the code in any scope. They can be changed at any time by any part of the program which makes them unreliable in larger complex programs. This can also lead to naming conflicts which can cause your code to fail or you to accidentally overwrite a global variable.</p><p name="008b" id="008b" class="graf graf--p graf-after--p">Defined in three ways:</p><ul class="postList"><li name="3c29" id="3c29" class="graf graf--li graf-after--p">Using a <code class="markup--code markup--li-code">var</code> statement outside of any function; <code class="markup--code markup--li-code">var foo = value</code>;</li><li name="accf" id="accf" class="graf graf--li graf-after--li">By adding a property to the global object (container of all global variables), such as <code class="markup--code markup--li-code">window</code> in browsers; <code class="markup--code markup--li-code">window.foo = value;</code></li><li name="7c49" id="7c49" class="graf graf--li graf-after--li">Using a variable without declaring it with <code class="markup--code markup--li-code">var</code>, which makes it an <em class="markup--em markup--li-em">implied global</em>; <code class="markup--code markup--li-code">foo = value</code></li></ul><h3 name="46c1" id="46c1" class="graf graf--h3 graf-after--li">Scope</h3><p name="a048" id="a048" class="graf graf--p graf-after--h3">Although JavaScript has block <em class="markup--em markup--p-em">syntax</em> (i.e. is written in blocks) like a lot of other programming languages, it has functional scope and <em class="markup--em markup--p-em">not</em> block scope.</p><p name="a64f" id="a64f" class="graf graf--p graf-after--p">Variables should all be declared at the top of the function and not littered throughout the block.</p><h3 name="ba7b" id="ba7b" class="graf graf--h3 graf-after--p">Semicolon Insertion</h3><p name="3374" id="3374" class="graf graf--p graf-after--h3">Attempts to correct faulty programs by automatically inserting semicolons. Do not depend on this as it can hide underlying issues.</p><p name="4cb9" id="4cb9" class="graf graf--p graf-after--p">Also ensure opening curly braces ({) are on the first line of a statement, otherwise semicolons will be erroneously inserted and cause problems:</p><pre name="266f" id="266f" class="graf graf--pre graf-after--p">//Ensure curly braces open on the first line of a statement<br>return {<br>    status: true    //for example<br>};<br>//instead of<br>return<br>{<br>    status:true<br>};</pre><h3 name="8a0d" id="8a0d" class="graf graf--h3 graf-after--pre">Reserved Words</h3><p name="433d" id="433d" class="graf graf--p graf-after--h3">Most JavaScript reserved words are not used in the language but cannot be used to name variables or parameters.</p><p name="ec56" id="ec56" class="graf graf--p graf-after--p">If used as the key in object literals, they <em class="markup--em markup--p-em">must</em> be quoted. For example <code class="markup--code markup--p-code">object - {&#39;case&#39; : value};</code> or <code class="markup--code markup--p-code">object[&#39;final&#39;] = value;</code> as <em class="markup--em markup--p-em">case</em> and <em class="markup--em markup--p-em">final</em> are both reserved words.</p><h3 name="c46c" id="c46c" class="graf graf--h3 graf-after--p">Unicode</h3><p name="8c4f" id="8c4f" class="graf graf--p graf-after--h3">JavaScript characters are 16 bits which only cover the original Unicode Basic Multilingual Place.</p><h3 name="c221" id="c221" class="graf graf--h3 graf-after--p">typeof</h3><p name="e972" id="e972" class="graf graf--p graf-after--h3">Watch out for:</p><ul class="postList"><li name="9377" id="9377" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">typeof null</code> which returns &#39;object&#39; instead of &#39;null&#39;</li><li name="c76a" id="c76a" class="graf graf--li graf-after--li">incorrect reporting on typeof regular expressions, with some implementations returning ‘object' and some returning ‘function'</li><li name="784a" id="784a" class="graf graf--li graf-after--li">arrays are objects in JavaScript so <code class="markup--code markup--li-code">typeof array</code> will return &#39;object&#39;</li></ul><p name="1978" id="1978" class="graf graf--p graf-after--li">All <code class="markup--code markup--p-code">object</code>s are <em class="markup--em markup--p-em">truthy</em> and <code class="markup--code markup--p-code">null</code> is <em class="markup--em markup--p-em">falsy</em>, so you can use the following to tell them apart:</p><pre name="b055" id="b055" class="graf graf--pre graf-after--p">if (my_value &amp;&amp; typeof my_value === &#39;object&#39;) {<br>    //then my value is definitely an object or an array because not only is its &#39;typeof&#39; an object but it&#39;s also truthy (first statement)<br>}</pre><h3 name="305d" id="305d" class="graf graf--h3 graf-after--pre">NaN</h3><ul class="postList"><li name="8dec" id="8dec" class="graf graf--li graf-after--h3"><code class="markup--code markup--li-code">typeof NaN === &#39;number&#39;</code> even though it stands for <em class="markup--em markup--li-em">not-a-number</em></li><li name="2301" id="2301" class="graf graf--li graf-after--li">If you have a chain of formulas that together produce a <code class="markup--code markup--li-code">NaN</code> then at least <em class="markup--em markup--li-em">one</em> of them will have generated <code class="markup--code markup--li-code">NaN</code></li><li name="a6f7" id="a6f7" class="graf graf--li graf-after--li">Surprisingly <code class="markup--code markup--li-code">NaN !=== NaN</code></li><li name="85e8" id="85e8" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">isNaN(value)</code> can be used to distinguish numbers from NaN</li></ul><p name="aa26" id="aa26" class="graf graf--p graf-after--li">For numbers, best use your own isNumber formula:</p><pre name="7d08" id="7d08" class="graf graf--pre graf-after--p">var isNumber = function isNumber(value) {<br>    return typeof value === &#39;number&#39; &amp;&amp; isFinite(value);    //isFinite() rejects NaN and Infinity, but is only good for numbers, not strings<br>}</pre><h3 name="4d3f" id="4d3f" class="graf graf--h3 graf-after--pre">Phony Arrays</h3><p name="9d98" id="9d98" class="graf graf--p graf-after--h3">JavaScript doesn't have real arrays, it has <em class="markup--em markup--p-em">array-like objects</em>.</p><ul class="postList"><li name="ed45" id="ed45" class="graf graf--li graf-after--p">Good: No need to give them dimensions and don't generate out-of-bounds errors</li><li name="a08f" id="a08f" class="graf graf--li graf-after--li">Bad: Slower than ‘real' arrays</li></ul><p name="4ca8" id="4ca8" class="graf graf--p graf-after--li">To test if value is an array:</p><pre name="e534" id="e534" class="graf graf--pre graf-after--p">if (my_value &amp;&amp; typeof my_value === &#39;object&#39; &amp;&amp; typeof my_value.length === &#39;number&#39; &amp;&amp;<br>    !(my_value.propertyIsEnumerable(&#39;length&#39;))) {<br>        //my_value is definitely an array!<br>}</pre><p name="e40c" id="e40c" class="graf graf--p graf-after--pre">The <code class="markup--code markup--p-code">arguments</code> array isn&#39;t an array, just an object with a length property.</p><h3 name="7379" id="7379" class="graf graf--h3 graf-after--p">Falsy Values</h3><p name="4156" id="4156" class="graf graf--p graf-after--h3"><code class="markup--code markup--p-code">0</code>, <code class="markup--code markup--p-code">NaN</code>, <code class="markup--code markup--p-code">&#39;&#39;</code>, <code class="markup--code markup--p-code">false</code>, <code class="markup--code markup--p-code">null</code> and <code class="markup--code markup--p-code">undefined</code> are all <em class="markup--em markup--p-em">falsy</em> values, but they are not interchangeable. When testing for a missing member of an object for example, you need to use <code class="markup--code markup--p-code">undefined</code> and not <code class="markup--code markup--p-code">null</code>.</p><p name="ac9a" id="ac9a" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">undefined</code> and <code class="markup--code markup--p-code">NaN</code> are actually global variables instead of constants but don&#39;t change their values.</p><h3 name="ffed" id="ffed" class="graf graf--h3 graf-after--p">Object</h3><p name="9f03" id="9f03" class="graf graf--p graf-after--h3">JavaScript objects inherit members from the prototype chain so they are <em class="markup--em markup--p-em">never truly empty</em>.</p><p name="8a64" id="8a64" class="graf graf--p graf-after--p">To test for membership without prototype chain involvement, use the <code class="markup--code markup--p-code">hasOwnProperty</code> method or limit your results (for example, to specific types like number so you know you&#39;re not dragging in object members from up the prototype for example if that&#39;s what&#39;s causing the problem).</p><h3 name="c689" id="c689" class="graf graf--h3 graf-after--p">Appendix B — the Bad Parts</h3><p name="5dc0" id="5dc0" class="graf graf--p graf-after--h3">Avoid these altogether</p><ul class="postList"><li name="f202" id="f202" class="graf graf--li graf-after--p"><code class="markup--code markup--li-code">==</code> and <code class="markup--code markup--li-code">!=</code>: Don&#39;t function properly when result is false, use <code class="markup--code markup--li-code">===</code> or <code class="markup--code markup--li-code">!==</code> instead</li><li name="8372" id="8372" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">with</code> statement: Intended to provide a shortcut to properties of an object but results vary every time it is run</li><li name="f087" id="f087" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">eval</code>: Adds unnecessary complication and compromises the security of the application</li><li name="e901" id="e901" class="graf graf--li graf-after--li">Giving string arguments to <code class="markup--code markup--li-code">setTimeout</code> and <code class="markup--code markup--li-code">setInterval</code> should also be avoided as this makes them act like <code class="markup--code markup--li-code">eval</code></li><li name="0eed" id="0eed" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">continue</code> statement: Forces a loop into its next iteration but the code is usually much improved when re-written <em class="markup--em markup--li-em">without</em> <code class="markup--code markup--li-code">continue</code></li><li name="fd9a" id="fd9a" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">switch</code> fall through: In a <code class="markup--code markup--li-code">switch</code> statement, each <code class="markup--code markup--li-code">case</code> falls through to the next <code class="markup--code markup--li-code">case</code> unless you explicitly disrupt the flow, but using these <em class="markup--em markup--li-em">intentional</em> fall throughs makes the <em class="markup--em markup--li-em">unintentional</em> ones that are causing errors basically impossible to find</li><li name="18f6" id="18f6" class="graf graf--li graf-after--li">This is one of those parts of JavaScript that appears useful but you're better off avoiding because it's occasionally very dangerous</li><li name="9a42" id="9a42" class="graf graf--li graf-after--li">Block-less statements: <em class="markup--em markup--li-em">Always</em> use curly braces <code class="markup--code markup--li-code">{}</code> to block in statements so as to avoid misinterpretation and aid error finding</li><li name="75ca" id="75ca" class="graf graf--li graf-after--li">Bitwise operators: Shouldn't really be doing this kind of manipulations because they are quite slow in JavaScript, therefore there shouldn't be a need to use <code class="markup--code markup--li-code">&amp;</code>, <code class="markup--code markup--li-code">|</code>, <code class="markup--code markup--li-code">ˆ</code>, <code class="markup--code markup--li-code">˜</code>, <code class="markup--code markup--li-code">&gt;&gt;</code>, <code class="markup--code markup--li-code">&gt;&gt;&gt;</code> or <code class="markup--code markup--li-code">&lt;&lt;</code></li><li name="aee0" id="aee0" class="graf graf--li graf-after--li">This doesn't mean you can't use <code class="markup--code markup--li-code">&amp;&amp;</code> for example</li><li name="8377" id="8377" class="graf graf--li graf-after--li"><code class="markup--code markup--li-code">++</code> and <code class="markup--code markup--li-code">--</code>: This one seems debatable to me; Douglas Crockford finds it makes his coding style much more cryptic and difficult to read (the book uses <code class="markup--code markup--li-code">+=1</code> and <code class="markup--code markup--li-code">-=1</code> instead)</li></ul><p name="e565" id="e565" class="graf graf--p graf-after--li">The function statement vs the function expression: To use JavaScript well, important to understand that functions are values.</p><ul class="postList"><li name="142a" id="142a" class="graf graf--li graf-after--p">A function <em class="markup--em markup--li-em">statement</em> is shorthand for a var statement with a function value, so <code class="markup--code markup--li-code">function foo() {}</code> (a function statement) means pretty much the same as <code class="markup--code markup--li-code">var foo = function foo(){};</code> (a function expression)</li><li name="0d8f" id="0d8f" class="graf graf--li graf-after--li">Logically, to write the language well you should define a function before using it, but in JavaScript, function statements (using just <code class="markup--code markup--li-code">function foo(){}</code>) are <em class="markup--em markup--li-em">hoisted</em> to the top of the scope in which they are defined - this encourages sloppy programming and should be avoided</li><li name="e15d" id="e15d" class="graf graf--li graf-after--li">function statements also don't function consistently in <code class="markup--code markup--li-code">if</code> statements</li><li name="89b5" id="89b5" class="graf graf--li graf-after--li">if you need to start a function expression with the word <em class="markup--em markup--li-em">function</em>, wrap it in parentheses (), or JavaScript assumes it's a function <em class="markup--em markup--li-em">statement</em></li></ul><p name="725f" id="725f" class="graf graf--p graf-after--li">Typed wrappers: Don't use <code class="markup--code markup--p-code">new Boolean</code> or <code class="markup--code markup--p-code">new String</code> or <code class="markup--code markup--p-code">new Number</code>, it&#39;s completely unnecessary. Also avoid <code class="markup--code markup--p-code">new Object</code> and <code class="markup--code markup--p-code">new Array</code> and use <code class="markup--code markup--p-code">{}</code> and <code class="markup--code markup--p-code">[]</code> instead.</p><p name="9ad8" id="9ad8" class="graf graf--p graf-after--p"><code class="markup--code markup--p-code">new</code> operator: Functions that are intended to be used with <code class="markup--code markup--p-code">new</code> (conventionally starting with a capital letter) should be avoided (don&#39;t define them) as they can cause all kinds of issues and complex bugs which are difficult to catch.</p><p name="2219" id="2219" class="graf graf--p graf-after--p">void: In JavaScript, this actually <em class="markup--em markup--p-em">takes</em> a value and <em class="markup--em markup--p-em">returns</em> <code class="markup--code markup--p-code">undefined</code>, which is hugely confusing and not helpful. Don&#39;t use it.</p><h3 name="d47b" id="d47b" class="graf graf--h3 graf-after--p">Appendix C — JSLint</h3><p name="8a6f" id="8a6f" class="graf graf--p graf-after--h3">JSLint is a code quality tool for JavaScript which checks your syntax.</p><p name="8efc" id="8efc" class="graf graf--p graf-after--p">Having read through this appendix (you can read more about <a href="http://www.jslint.com/" data-href="http://www.jslint.com/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank">JSLint here</a>), I tend more towards <a href="http://jshint.com/about/" data-href="http://jshint.com/about/" class="markup--anchor markup--p-anchor" rel="nofollow noopener" target="_blank"><em class="markup--em markup--p-em">JSHint</em></a>, a <em class="markup--em markup--p-em">fork</em> of JSLint. It allows programmers to customise for themselves which the good parts and bad parts are and define their own subset, although naturally there are a number of pre-defined options. <a href="https://github.com/nelsonic/learn-jshint" data-href="https://github.com/nelsonic/learn-jshint" class="markup--anchor markup--p-anchor" rel="noopener" target="_blank">This is a really fantastic article on using JSHint</a>; it's simple and aimed at having you using JSHint in a few minutes as well as providing various sources for pre-defined subsets.</p><h4 name="aa37" id="aa37" class="graf graf--h4 graf-after--p">Further resources:</h4><div name="9171" id="9171" class="graf graf--mixtapeEmbed graf-after--h4"><a href="https://bryanguner.medium.com/a-list-of-all-of-my-articles-to-link-to-future-posts-1f6f88ebdf5b" data-href="https://bryanguner.medium.com/a-list-of-all-of-my-articles-to-link-to-future-posts-1f6f88ebdf5b" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://bryanguner.medium.com/a-list-of-all-of-my-articles-to-link-to-future-posts-1f6f88ebdf5b"><strong class="markup--strong markup--mixtapeEmbed-strong">A list of all of my articles to link to future posts</strong><br><em class="markup--em markup--mixtapeEmbed-em">You should probably skip this one… seriously it's just for internal use!</em>bryanguner.medium.com</a><a href="https://bryanguner.medium.com/a-list-of-all-of-my-articles-to-link-to-future-posts-1f6f88ebdf5b" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="dd1d7f5e952c9d85244acd597e1e7811"></a></div><div name="1c2f" id="1c2f" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://gist.github.com/bgoonz" data-href="https://gist.github.com/bgoonz" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://gist.github.com/bgoonz"><strong class="markup--strong markup--mixtapeEmbed-strong">bgoonz's gists</strong><br><em class="markup--em markup--mixtapeEmbed-em">Instantly share code, notes, and snippets. Web Developer, Electrical Engineer JavaScript | CSS | Bootstrap | Python |…</em>gist.github.com</a><a href="https://gist.github.com/bgoonz" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="ab25adbb500306703daab23d08a7739a" data-thumbnail-img-id="0*3O67jrqm3EHjTK2H" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*3O67jrqm3EHjTK2H);"></a></div><div name="3585" id="3585" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed"><a href="https://github.com/bgoonz" data-href="https://github.com/bgoonz" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://github.com/bgoonz"><strong class="markup--strong markup--mixtapeEmbed-strong">bgoonz — Overview</strong><br><em class="markup--em markup--mixtapeEmbed-em">Web Developer, Electrical Engineer JavaScript | CSS | Bootstrap | Python | React | Node.js | Express | Sequelize…</em>github.com</a><a href="https://github.com/bgoonz" class="js-mixtapeImage mixtapeImage u-ignoreBlock" data-media-id="6ee74d5200d495ddc7ddad0c92bd6dce" data-thumbnail-img-id="0*Udg3rbeFyslZ9dyl" style="background-image: url(https://cdn-images-1.medium.com/fit/c/160/160/0*Udg3rbeFyslZ9dyl);"></a></div><div name="4bce" id="4bce" class="graf graf--mixtapeEmbed graf-after--mixtapeEmbed graf--trailing"><a href="https://web-dev-resource-hub.netlify.app/" data-href="https://web-dev-resource-hub.netlify.app/" class="markup--anchor markup--mixtapeEmbed-anchor" title="https://web-dev-resource-hub.netlify.app/"><strong class="markup--strong markup--mixtapeEmbed-strong">Web-Dev-Resource-Hub</strong><br><em class="markup--em markup--mixtapeEmbed-em">Edit description</em>web-dev-resource-hub.netlify.app</a><a href="https://web-dev-resource-hub.netlify.app/" class="js-mixtapeImage mixtapeImage mixtapeImage--empty u-ignoreBlock" data-media-id="142b348a1c3b7cab095decda3afd6236"></a></div></div></div></section>
</section>
<footer><p>By <a href="https://medium.com/@bryanguner" class="p-author h-card">Bryan Guner</a> on <a href="https://medium.com/p/8194aad6a465"><time class="dt-published" datetime="2021-04-05T07:47:41.298Z">April 5, 2021</time></a>.</p><p><a href="https://medium.com/@bryanguner/notes-from-javascript-the-good-parts-8194aad6a465" class="p-canonical">Canonical link</a></p><p>Exported from <a href="https://medium.com">Medium</a> on April 8, 2021.</p></footer></article></body></html>
